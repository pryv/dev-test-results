[
  {
    "stats": {
      "suites": 163,
      "tests": 457,
      "passes": 453,
      "pending": 4,
      "failures": 0,
      "start": "2019-05-06T11:52:02.950Z",
      "end": "2019-05-06T11:53:20.706Z",
      "duration": 77756
    },
    "tests": [
      {
        "title": "should contain deletions",
        "fullTitle": "access deletions when given a few existing accesses accesses.get should contain deletions",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains active accesses",
        "fullTitle": "access deletions when given a few existing accesses accesses.get contains active accesses",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains deleted accesses as well",
        "fullTitle": "access deletions when given a few existing accesses accesses.get contains deleted accesses as well",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "deleted access are in UTC (seconds) format",
        "fullTitle": "access deletions when given a few existing accesses accesses.get deleted access are in UTC (seconds) format",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain an access",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a valid access should contain an access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain the set values, but no \"deleted\" field in the API response",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a valid access should contain the set values, but no \"deleted\" field in the API response",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain the field \"deleted:null\" in the database",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a valid access should contain the field \"deleted:null\" in the database",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an error",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a deleted access should return an error",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "error should say that the deleted field is forbidden upon creation",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a deleted access error should say that the deleted field is forbidden upon creation",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an error",
        "fullTitle": "access deletions when given a few existing accesses accesses.update should return an error",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "error should say that the deleted field is forbidden upon update",
        "fullTitle": "access deletions when given a few existing accesses accesses.update error should say that the deleted field is forbidden upon update",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access expiry when given a few existing accesses accesses.get vanilla version succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains only active accesses",
        "fullTitle": "access expiry when given a few existing accesses accesses.get vanilla version contains only active accesses",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access expiry when given a few existing accesses accesses.get when given the includeExpired=true parameter succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "includes expired accesses",
        "fullTitle": "access expiry when given a few existing accesses accesses.get when given the includeExpired=true parameter includes expired accesses",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an access with set expiry timestamp",
        "fullTitle": "access expiry when given a few existing accesses accesses.create when called with expireAfter>0 creates an access with set expiry timestamp",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an expired access",
        "fullTitle": "access expiry when given a few existing accesses accesses.create when called with expireAfter=0 creates an expired access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "access expiry when given a few existing accesses accesses.create when called with expireAfter<0 fails",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "sets the 'expires' attribute",
        "fullTitle": "access expiry when given a few existing accesses accesses.update with expireAfter>0 sets the 'expires' attribute",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "expires the access immediately",
        "fullTitle": "access expiry when given a few existing accesses accesses.update with expireAfter=0 expires the access immediately",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "removes expiry",
        "fullTitle": "access expiry when given a few existing accesses accesses.update with expires=null removes expiry",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "access expiry when given a few existing accesses accesses.update when trying to update itself with a longer expiration fails",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the matching access",
        "fullTitle": "access expiry when given a few existing accesses accesses.checkApp when the matching access is not expired returns the matching access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns no match",
        "fullTitle": "access expiry when given a few existing accesses accesses.checkApp when the matching access is expired returns no match",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "access expiry when given a few existing accesses other API accesses using an expired access fails",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns a proper error message",
        "fullTitle": "access expiry when given a few existing accesses other API accesses using an expired access returns a proper error message",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access expiry when given a few existing accesses other API accesses using a valid access succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access client data when given a few existing accesses accesses.get succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains existing accesses with clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.get contains existing accesses with clientData",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an access with empty clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.create when called with clientData={} creates an access with empty clientData",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws a schema error",
        "fullTitle": "access client data when given a few existing accesses accesses.create when called with clientData=null throws a schema error",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an access with complex clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.create when called with complex clientData creates an access with complex clientData",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "updates previous clientData with new clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.update if existing clientData was not empty updates previous clientData with new clientData",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "keeps existing clientData untouched",
        "fullTitle": "access client data when given a few existing accesses accesses.update if clientData is not provided keeps existing clientData untouched",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "sets clientData to provided clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.update if existing clientData was empty sets clientData to provided clientData",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "removes existing clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.update if provided clientData is explicitely null removes existing clientData",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the matching access",
        "fullTitle": "access client data when given a few existing accesses accesses.checkApp when the provided clientData matches the existing clientData returns the matching access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns no match",
        "fullTitle": "access client data when given a few existing accesses accesses.checkApp when the provided clientData does not match the existing clientData returns no match",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns no match",
        "fullTitle": "access client data when given a few existing accesses accesses.checkApp when no clientData is provided but existing access has one returns no match",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "users pool create pool user succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains a generated pool user id",
        "fullTitle": "users pool create pool user contains a generated pool user id",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "created a user in the database",
        "fullTitle": "users pool create pool user created a user in the database",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "created the related collections",
        "fullTitle": "users pool create pool user created the related collections",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "created the related indexes",
        "fullTitle": "users pool create pool user created the related indexes",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must succeed",
        "fullTitle": "users pool get pool size when empty must succeed",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return 0",
        "fullTitle": "users pool get pool size when empty must return 0",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "users pool get pool size when adding pool users succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "has the right number of pool users",
        "fullTitle": "users pool get pool size when adding pool users has the right number of pool users",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return shared accesses whose permissions are a subset of the current one's",
        "fullTitle": "accesses (app) GET / must return shared accesses whose permissions are a subset of the current one's",
        "duration": 67,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to requests with a shared access token",
        "fullTitle": "accesses (app) GET / must be forbidden to requests with a shared access token",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new shared access with the sent data and return it",
        "fullTitle": "accesses (app) POST / must create a new shared access with the sent data and return it",
        "duration": 43,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to create a non-shared access",
        "fullTitle": "accesses (app) POST / must forbid trying to create a non-shared access",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to create an access with greater permissions",
        "fullTitle": "accesses (app) POST / must forbid trying to create an access with greater permissions",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "accesses (app) POST / must return a correct error if the sent data is badly formatted",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creation of shared accesses with an access that has superior permission on root stream (*)",
        "fullTitle": "accesses (app) POST / must allow creation of shared accesses with an access that has superior permission on root stream (*)",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the access with the sent data",
        "fullTitle": "accesses (app) PUT /<token> must modify the access with the sent data",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to modify a non-shared access",
        "fullTitle": "accesses (app) PUT /<token> must forbid trying to modify a non-shared access",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to modify an access with greater permissions",
        "fullTitle": "accesses (app) PUT /<token> must forbid trying to modify an access with greater permissions",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the access does not exist",
        "fullTitle": "accesses (app) PUT /<token> must return a correct error if the access does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "accesses (app) PUT /<token> must return a correct error if the sent data is badly formatted",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if an access with the same name already exists",
        "fullTitle": "accesses (app) PUT /<token> must return a correct error if an access with the same name already exists",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the shared access",
        "fullTitle": "accesses (app) DELETE /<token> must delete the shared access",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to delete a non-shared access",
        "fullTitle": "accesses (app) DELETE /<token> must forbid trying to delete a non-shared access",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to delete an access with greater permissions",
        "fullTitle": "accesses (app) DELETE /<token> must forbid trying to delete an access with greater permissions",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the access does not exist",
        "fullTitle": "accesses (app) DELETE /<token> must return a correct error if the access does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all accesses (including personal ones)",
        "fullTitle": "accesses (personal) GET / must return all accesses (including personal ones)",
        "duration": 13,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new shared access with the sent data, returning it",
        "fullTitle": "accesses (personal) POST / must create a new shared access with the sent data, returning it",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new app access with the sent data, creating/restoring requested streams",
        "fullTitle": "accesses (personal) POST / must create a new app access with the sent data, creating/restoring requested streams",
        "duration": 79,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept two app accesses with the same name (app ids) but different device names",
        "fullTitle": "accesses (personal) POST / must accept two app accesses with the same name (app ids) but different device names",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must ignore erroneous requests to create new streams",
        "fullTitle": "accesses (personal) POST / must ignore erroneous requests to create new streams",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if a stream similar to that requested for creation already exists",
        "fullTitle": "accesses (personal) POST / must fail if a stream similar to that requested for creation already exists",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse to create new personal accesses (obtained via login only)",
        "fullTitle": "accesses (personal) POST / must refuse to create new personal accesses (obtained via login only)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must slugify the new access' predefined token",
        "fullTitle": "accesses (personal) POST / must slugify the new access' predefined token",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "accesses (personal) POST / must return an error if the sent data is badly formatted",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse empty `defaultName` values for streams",
        "fullTitle": "accesses (personal) POST / must refuse empty `defaultName` values for streams",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an access with the same token already exists",
        "fullTitle": "accesses (personal) POST / must return an error if an access with the same token already exists",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an access with the same name already exists",
        "fullTitle": "accesses (personal) POST / must return an error if an access with the same name already exists",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an \"app\" access with the same name (app id) and device name already exists",
        "fullTitle": "accesses (personal) POST / must return an error if an \"app\" access with the same name (app id) and device name already exists",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the device name is set for a non-app access",
        "fullTitle": "accesses (personal) POST / must return an error if the device name is set for a non-app access",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the given predefined access's token is a reserved word",
        "fullTitle": "accesses (personal) POST / must return an error if the given predefined access's token is a reserved word",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the shared access with the sent data",
        "fullTitle": "accesses (personal) PUT /<token> must modify the shared access with the sent data",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the personal access with the specified data",
        "fullTitle": "accesses (personal) PUT /<token> must modify the personal access with the specified data",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the access does not exist",
        "fullTitle": "accesses (personal) PUT /<token> must return an error if the access does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "accesses (personal) PUT /<token> must return an error if the sent data is badly formatted",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an access with the same name and type already exists",
        "fullTitle": "accesses (personal) PUT /<token> must return an error if an access with the same name and type already exists",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and throw a forbidden error in strict mode",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must prevent update of protected fields and throw a forbidden error in strict mode",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and log a warning in non-strict mode",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must prevent update of protected fields and log a warning in non-strict mode",
        "duration": 1144,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid to elevate a read level into a manage level using a contribute access ",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must forbid to elevate a read level into a manage level using a contribute access ",
        "duration": 62,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid to extend the permission streamIds beyond the authorized context ",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must forbid to extend the permission streamIds beyond the authorized context ",
        "duration": 62,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the shared access",
        "fullTitle": "accesses (personal) DELETE /<token> must delete the shared access",
        "duration": 33,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the personal access",
        "fullTitle": "accesses (personal) DELETE /<token> must delete the personal access",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the access does not exist",
        "fullTitle": "accesses (personal) DELETE /<token> must return an error if the access does not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the adjusted permissions structure if no access exists",
        "fullTitle": "accesses (personal) POST /check-app must return the adjusted permissions structure if no access exists",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept requested permissions with \"*\" for \"all streams\"",
        "fullTitle": "accesses (personal) POST /check-app must accept requested permissions with \"*\" for \"all streams\"",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the existing app access if matching",
        "fullTitle": "accesses (personal) POST /check-app must return the existing app access if matching",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must also return the token of the existing mismatching access if any",
        "fullTitle": "accesses (personal) POST /check-app must also return the token of the existing mismatching access if any",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must propose fixes to duplicate ids of streams and signal an error when appropriate",
        "fullTitle": "accesses (personal) POST /check-app must propose fixes to duplicate ids of streams and signal an error when appropriate",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "accesses (personal) POST /check-app must return an error if the sent data is badly formatted",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "accesses (personal) POST /check-app must be forbidden to non-personal accesses",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the user's account details",
        "fullTitle": "account GET / must return the user's account details",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "account GET / must be forbidden to non-personal accesses",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify account details with the sent data, notifying register if e-mail changed",
        "fullTitle": "account PUT / must modify account details with the sent data, notifying register if e-mail changed",
        "duration": 1237,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "account PUT / must return a correct error if the sent data is badly formatted",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "account PUT / must be forbidden to non-personal accesses",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly compute used storage size for a given user when called",
        "fullTitle": "account storage space monitoring must properly compute used storage size for a given user when called",
        "duration": 133,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly compute storage size for all users in nightly script",
        "fullTitle": "account storage space monitoring must properly compute storage size for all users in nightly script",
        "duration": 1114,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be approximately updated (diff) when adding an attached file",
        "fullTitle": "account storage space monitoring must be approximately updated (diff) when adding an attached file",
        "duration": 47,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be approximately updated (diff) when deleting an attached file",
        "fullTitle": "account storage space monitoring must be approximately updated (diff) when deleting an attached file",
        "duration": 51,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be approximately updated (diff) when deleting an event",
        "fullTitle": "account storage space monitoring must be approximately updated (diff) when deleting an event",
        "duration": 77,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must change the password to the given value",
        "fullTitle": "account /change-password must change the password to the given value",
        "duration": 278,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the given old password does not match",
        "fullTitle": "account /change-password must return an error if the given old password does not match",
        "duration": 89,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "account /change-password must return a correct error if the sent data is badly formatted",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "account /change-password must be forbidden to non-personal accesses",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"request\" must trigger an email with a reset token, store that token, then \"reset\" must reset the password to the given value",
        "fullTitle": "account /request-password-reset and /reset-password \"request\" must trigger an email with a reset token, store that token, then \"reset\" must reset the password to the given value",
        "duration": 1475,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not trigger a reset email if mailing is deactivated",
        "fullTitle": "account /request-password-reset and /reset-password must not trigger a reset email if mailing is deactivated",
        "duration": 1214,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not trigger a reset email if reset mail is deactivated",
        "fullTitle": "account /request-password-reset and /reset-password must not trigger a reset email if reset mail is deactivated",
        "duration": 1206,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not be possible to use a reset token to illegally change password of another user",
        "fullTitle": "account /request-password-reset and /reset-password must not be possible to use a reset token to illegally change password of another user",
        "duration": 27,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"request\" must return an error if the requesting app is not trusted",
        "fullTitle": "account /request-password-reset and /reset-password \"request\" must return an error if the requesting app is not trusted",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"request\" must return an error if sent data is badly formatted",
        "fullTitle": "account /request-password-reset and /reset-password \"request\" must return an error if sent data is badly formatted",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"reset\" must return an error if the reset token is invalid/expired",
        "fullTitle": "account /request-password-reset and /reset-password \"reset\" must return an error if the reset token is invalid/expired",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"reset\" must return an error if the requesting app is not trusted",
        "fullTitle": "account /request-password-reset and /reset-password \"reset\" must return an error if the requesting app is not trusted",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"reset\" must return an error if sent data is badly formatted",
        "fullTitle": "account /request-password-reset and /reset-password \"reset\" must return an error if sent data is badly formatted",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not return history when calling events.get",
        "fullTitle": "Auditing Events must not return history when calling events.get",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the event's history when deleting it with deletionMode=keep-nothing",
        "fullTitle": "Auditing Events deletionMode must delete the event's history when deleting it with deletionMode=keep-nothing",
        "duration": 1165,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must minimize the event's history when deleting it with deletionMode=keep-authors",
        "fullTitle": "Auditing Events deletionMode must minimize the event's history when deleting it with deletionMode=keep-authors",
        "duration": 1152,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not modify the event's history when deleting it with deletionMode=keep-everything",
        "fullTitle": "Auditing Events deletionMode must not modify the event's history when deleting it with deletionMode=keep-everything",
        "duration": 1137,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not return an event's history when calling getOne with includeHistory flag off",
        "fullTitle": "Auditing Events getOne must not return an event's history when calling getOne with includeHistory flag off",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an event's history when calling getOne with includeHistory flag on",
        "fullTitle": "Auditing Events getOne must return an event's history when calling getOne with includeHistory flag on",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when updating an event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history when updating an event",
        "duration": 138,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history of the running event that was stopped because of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history of the running event that was stopped because of the start call on another event",
        "duration": 65,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when no event was stopped in the procedure of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history when no event was stopped in the procedure of the start call on another event",
        "duration": 44,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when calling stop on a running event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history when calling stop on a running event",
        "duration": 46,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate history when updating an event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must generate history when updating an event",
        "duration": 178,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate history of the running event that was stopped because of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must generate history of the running event that was stopped because of the start call on another event",
        "duration": 74,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when no event was stopped in the procedure of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must not generate history when no event was stopped in the procedure of the start call on another event",
        "duration": 39,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate history when calling stop on a running event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must generate history when calling stop on a running event",
        "duration": 53,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate events' history when their stream is deleted with  mergeEventsWithParents=true since their streamId is modified",
        "fullTitle": "Auditing Streams must generate events' history when their stream is deleted with  mergeEventsWithParents=true since their streamId is modified",
        "duration": 135,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-nothing'",
        "fullTitle": "Auditing Streams must delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-nothing'",
        "duration": 1172,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must keep the events' minimal history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-authors'",
        "fullTitle": "Auditing Streams must keep the events' minimal history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-authors'",
        "duration": 1173,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-everything'",
        "fullTitle": "Auditing Streams must not delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-everything'",
        "duration": 1149,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete history data from the storage",
        "fullTitle": "Auditing Nightly task must delete history data from the storage",
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must authenticate the given credentials, open a session and return the access token",
        "fullTitle": "auth /login must authenticate the given credentials, open a session and return the access token",
        "duration": 165,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reuse the current session if already open",
        "fullTitle": "auth /login must reuse the current session if already open",
        "duration": 199,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept \"wildcarded\" app ids and origins",
        "fullTitle": "auth /login must accept \"wildcarded\" app ids and origins",
        "duration": 100,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept \"no origin\" (i.e. not a CORS request) if authorized",
        "fullTitle": "auth /login must accept \"no origin\" (i.e. not a CORS request) if authorized",
        "duration": 120,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "fullTitle": "auth /login must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "duration": 97,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "fullTitle": "auth /login must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not be case-sensitive for the username",
        "fullTitle": "auth /login must not be case-sensitive for the username",
        "duration": 103,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error when the local credentials are missing or invalid",
        "fullTitle": "auth /login must return a correct error when the local credentials are missing or invalid",
        "duration": 81,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the app id is missing or untrusted",
        "fullTitle": "auth /login must return a correct error if the app id is missing or untrusted",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the origin is missing or does not match the app id",
        "fullTitle": "auth /login must return a correct error if the origin is missing or does not match the app id",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must support concurrent login request",
        "fullTitle": "auth /login must support concurrent login request",
        "duration": 126,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not leak _private object from Result",
        "fullTitle": "auth /login must not leak _private object from Result",
        "duration": 95,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must replace the password in the logs by (hidden) when an error occurs",
        "fullTitle": "auth /login when we log into a temporary log file must replace the password in the logs by (hidden) when an error occurs",
        "duration": 144,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not mention the password in the logs when none is provided",
        "fullTitle": "auth /login when we log into a temporary log file must not mention the password in the logs when none is provided",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must terminate the access session and fail to logout a second time (session already expired)",
        "fullTitle": "auth /logout must terminate the access session and fail to logout a second time (session already expired)",
        "duration": 219,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "(or any request) must alternatively accept the access token in the query string",
        "fullTitle": "auth /logout (or any request) must alternatively accept the access token in the query string",
        "duration": 148,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "GET /who-am-i must return a 404 as it has been deprecated",
        "fullTitle": "auth SSO support GET /who-am-i must return a 404 as it has been deprecated",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must set the SSO cookie on /login with the access token",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must set the SSO cookie on /login with the access token",
        "duration": 160,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must answer /who-am-i with username and session details if session open",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must answer /who-am-i with username and session details if session open",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must clear the SSO cookie on /logout",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must clear the SSO cookie on /logout",
        "duration": 42,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must respond /who-am-i with an \"unauthorized\" error if no cookie is sent",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must respond /who-am-i with an \"unauthorized\" error if no cookie is sent",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the last 20 non-trashed events (sorted descending) by default",
        "fullTitle": "events GET / must return the last 20 non-trashed events (sorted descending) by default",
        "duration": 91,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events for the given streams (incl. sub-streams) when set",
        "fullTitle": "events GET / must only return events for the given streams (incl. sub-streams) when set",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if some of the given streams do not exist",
        "fullTitle": "events GET / must return an error if some of the given streams do not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events with the given tag when set",
        "fullTitle": "events GET / must only return events with the given tag when set",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events with any of the given tags when set",
        "fullTitle": "events GET / must only return events with any of the given tags when set",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events of any of the given types when set",
        "fullTitle": "events GET / must only return events of any of the given types when set",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must (unofficially) support a wildcard for event types",
        "fullTitle": "events GET / must (unofficially) support a wildcard for event types",
        "duration": 38,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events in the given time period sorted ascending when set",
        "fullTitle": "events GET / must only return events in the given time period sorted ascending when set",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must take into account fromTime and toTime even if set to 0",
        "fullTitle": "events GET / must take into account fromTime and toTime even if set to 0",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must take into account modifiedSince even if set to 0",
        "fullTitle": "events GET / must take into account modifiedSince even if set to 0",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly exclude period events completed before the given period",
        "fullTitle": "events GET / must properly exclude period events completed before the given period",
        "duration": 40,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return ongoing events started before the given time period",
        "fullTitle": "events GET / must return ongoing events started before the given time period",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events in the given paging range when set",
        "fullTitle": "events GET / must only return events in the given paging range when set",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return only trashed events when requested",
        "fullTitle": "events GET / must return only trashed events when requested",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all events (trashed or not) when requested",
        "fullTitle": "events GET / must return all events (trashed or not) when requested",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return only events modified since the given time when requested",
        "fullTitle": "events GET / must return only events modified since the given time when requested",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must include event deletions (since that time) when requested",
        "fullTitle": "events GET / must include event deletions (since that time) when requested",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not keep event deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "fullTitle": "events GET / must not keep event deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return running period event(s) when requested",
        "fullTitle": "events GET / must only return running period event(s) when requested",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if no access token is provided",
        "fullTitle": "events GET / must return an error if no access token is provided",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the attached file with the correct headers",
        "fullTitle": "events GET /<event id>/<file id> must return the attached file with the correct headers",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept a secure read token in the query string instead of the `\"Authorization\" header",
        "fullTitle": "events GET /<event id>/<file id> must accept a secure read token in the query string instead of the `\"Authorization\" header",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow a filename path suffix after the file id",
        "fullTitle": "events GET /<event id>/<file id> must allow a filename path suffix after the file id",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow any filename (including special characters)",
        "fullTitle": "events GET /<event id>/<file id> must allow any filename (including special characters)",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse an invalid file read token",
        "fullTitle": "events GET /<event id>/<file id> must refuse an invalid file read token",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse auth via the regular \"auth\" query string parameter",
        "fullTitle": "events GET /<event id>/<file id> must refuse auth via the regular \"auth\" query string parameter",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if trying to get an unknown attachment",
        "fullTitle": "events GET /<event id>/<file id> must return a proper error if trying to get an unknown attachment",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create an event with the sent data, returning it",
        "fullTitle": "events POST / must create an event with the sent data, returning it",
        "duration": 39,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must set the event's time to \"now\" if missing",
        "fullTitle": "events POST / must set the event's time to \"now\" if missing",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "events POST / must accept explicit null for optional fields",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse events with no stream id",
        "fullTitle": "events POST / must refuse events with no stream id",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if an event with the same id already exists",
        "fullTitle": "events POST / must return a correct error if an event with the same id already exists",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not allow reuse of deleted ids (unlike streams)",
        "fullTitle": "events POST / must not allow reuse of deleted ids (unlike streams)",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only allow ids that are formatted like cuids",
        "fullTitle": "events POST / must only allow ids that are formatted like cuids",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reject tags that are too long",
        "fullTitle": "events POST / must reject tags that are too long",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fix the tags to an empty array if not set",
        "fullTitle": "events POST / must fix the tags to an empty array if not set",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must try casting string event content to number if appropriate",
        "fullTitle": "events POST / must try casting string event content to number if appropriate",
        "duration": 38,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not stop the running period event if the new event is a mark event (single activity)",
        "fullTitle": "events POST / must not stop the running period event if the new event is a mark event (single activity)",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not stop the running period event if the stream allows overlapping",
        "fullTitle": "events POST / must not stop the running period event if the stream allows overlapping",
        "duration": 43,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must validate the event's content if its type is known",
        "fullTitle": "events POST / must validate the event's content if its type is known",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not fail when validating the content if passing a string instead of an object",
        "fullTitle": "events POST / must not fail when validating the content if passing a string instead of an object",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "events POST / must return an error if the sent data is badly formatted",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the associated stream is unknown",
        "fullTitle": "events POST / must return an error if the associated stream is unknown",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the event's period overlaps existing periods (single activity)",
        "fullTitle": "events POST / must return an error if the event's period overlaps existing periods (single activity)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow the event's period overlapping existing periods when the stream allows it",
        "fullTitle": "events POST / must allow the event's period overlapping existing periods when the stream allows it",
        "duration": 31,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the assigned stream is trashed",
        "fullTitle": "events POST / must return an error if the assigned stream is trashed",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not fail (500) when sending an array instead of an object",
        "fullTitle": "events POST / must not fail (500) when sending an array instead of an object",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a running period event stopping any previously running event (single activity)",
        "fullTitle": "events POST /start must create a running period event stopping any previously running event (single activity)",
        "duration": 51,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if a period event already exists later (single activity)",
        "fullTitle": "events POST /start must return an error if a period event already exists later (single activity)",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow starting an event before an existing period when the stream allows overlapping",
        "fullTitle": "events POST /start must allow starting an event before an existing period when the stream allows overlapping",
        "duration": 33,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new event with the uploaded files",
        "fullTitle": "events POST / (multipart content) must create a new event with the uploaded files",
        "duration": 95,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly handle part names containing special chars (e.g. \".\", \"$\")",
        "fullTitle": "events POST / (multipart content) must properly handle part names containing special chars (e.g. \".\", \"$\")",
        "duration": 70,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the non-file content part is not JSON",
        "fullTitle": "events POST / (multipart content) must return an error if the non-file content part is not JSON",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if there is more than one non-file content part",
        "fullTitle": "events POST / (multipart content) must return an error if there is more than one non-file content part",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add the uploaded files to the event as attachments",
        "fullTitle": "events POST /<event id> (multipart content) must add the uploaded files to the event as attachments",
        "duration": 71,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add the uploaded files to the event without replacing existing attachments",
        "fullTitle": "events POST /<event id> (multipart content) must add the uploaded files to the event without replacing existing attachments",
        "duration": 58,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "allows access at level=read",
        "fullTitle": "events GET /<id> allows access at level=read",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "denies access without authorization",
        "fullTitle": "events GET /<id> denies access without authorization",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the event with the sent data",
        "fullTitle": "events PUT /<id> must modify the event with the sent data",
        "duration": 38,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add/update/remove the specified client data fields without touching the others",
        "fullTitle": "events PUT /<id> must add/update/remove the specified client data fields without touching the others",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the id of the stopped previously running event if any (single activity)",
        "fullTitle": "events PUT /<id> must return the id of the stopped previously running event if any (single activity)",
        "duration": 45,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "events PUT /<id> must accept explicit null for optional fields",
        "duration": 44,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must validate the event's content if its type is known",
        "fullTitle": "events PUT /<id> must validate the event's content if its type is known",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the event does not exist",
        "fullTitle": "events PUT /<id> must return an error if the event does not exist",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "events PUT /<id> must return an error if the sent data is badly formatted",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the associated stream is unknown",
        "fullTitle": "events PUT /<id> must return an error if the associated stream is unknown",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if moving a running period event before another existing period event (single activity)",
        "fullTitle": "events PUT /<id> must return an error if moving a running period event before another existing period event (single activity)",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the event's new period overlaps other events's (single activity)",
        "fullTitle": "events PUT /<id> must return an error if the event's new period overlaps other events's (single activity)",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reject tags that are too long",
        "fullTitle": "events PUT /<id> must reject tags that are too long",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and throw a forbidden error in strict mode",
        "fullTitle": "events PUT /<id> forbidden updates of protected fields must prevent update of protected fields and throw a forbidden error in strict mode",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and log a warning in non-strict mode",
        "fullTitle": "events PUT /<id> forbidden updates of protected fields must prevent update of protected fields and log a warning in non-strict mode",
        "duration": 1148,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must stop the previously running period event, returning its id (single activity)",
        "fullTitle": "events POST /stop must stop the previously running period event, returning its id (single activity)",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must stop the last running event of the given type when specified",
        "fullTitle": "events POST /stop must stop the last running event of the given type when specified",
        "duration": 55,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept an `id` param to specify the event to stop",
        "fullTitle": "events POST /stop must accept an `id` param to specify the event to stop",
        "duration": 57,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the specified event does not exist",
        "fullTitle": "events POST /stop must return an error if the specified event does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the specified event is not running",
        "fullTitle": "events POST /stop must return an error if the specified event is not running",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if no event is specified and the stream allows overlapping",
        "fullTitle": "events POST /stop must return an error if no event is specified and the stream allows overlapping",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if neither stream nor event is specified",
        "fullTitle": "events POST /stop must return an error if neither stream nor event is specified",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the attachment (reference in event + file)",
        "fullTitle": "events DELETE /<event id>/<file id> must delete the attachment (reference in event + file)",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if not existing",
        "fullTitle": "events DELETE /<event id>/<file id> must return an error if not existing",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must flag the event as trashed",
        "fullTitle": "events DELETE /<id> must flag the event as trashed",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the event when already trashed including all its attachments",
        "fullTitle": "events DELETE /<id> must delete the event when already trashed including all its attachments",
        "duration": 77,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all followed slices (ordered by user name, then access token)",
        "fullTitle": "followed slices GET / must return all followed slices (ordered by user name, then access token)",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "followed slices GET / must be forbidden to non-personal accesses",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new followed slice with the sent data, returning it",
        "fullTitle": "followed slices POST / must create a new followed slice with the sent data, returning it",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "followed slices POST / must return a correct error if the sent data is badly formatted",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the same followed slice (url and token) already exists",
        "fullTitle": "followed slices POST / must return a correct error if the same followed slice (url and token) already exists",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if a followed slice with the same name already exists",
        "fullTitle": "followed slices POST / must return a correct error if a followed slice with the same name already exists",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the followed slice with the sent data",
        "fullTitle": "followed slices PUT /<id> must modify the followed slice with the sent data",
        "duration": 31,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the followed slice does not exist",
        "fullTitle": "followed slices PUT /<id> must return a correct error if the followed slice does not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "followed slices PUT /<id> must return a correct error if the sent data is badly formatted",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if a followed slice with the same name already exists",
        "fullTitle": "followed slices PUT /<id> must return a correct error if a followed slice with the same name already exists",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the followed slice",
        "fullTitle": "followed slices DELETE /<id> must delete the followed slice",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the followed slice does not exist",
        "fullTitle": "followed slices DELETE /<id> must return a correct error if the followed slice does not exist",
        "duration": 13,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with streams schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with streams schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with streams schema must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with events schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with events schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with events schema must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with accesses schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with accesses schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with accesses schema must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should throw an error if mailing method is invalid",
        "fullTitle": "Mailing helper methods should throw an error if mailing method is invalid",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should throw an error if mailing method is missing",
        "fullTitle": "Mailing helper methods should throw an error if mailing method is missing",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should not be empty",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should not be empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid auth key",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain a valid auth key",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid recipient",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain a valid recipient",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid substitution of variables",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain a valid substitution of variables",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain valid tags",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain valid tags",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should not be empty",
        "fullTitle": "Mailing helper methods using Microservice validating request body should not be empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid auth key",
        "fullTitle": "Mailing helper methods using Microservice validating request body should contain a valid auth key",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid recipient",
        "fullTitle": "Mailing helper methods using Microservice validating request body should contain a valid recipient",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid substitution of variables",
        "fullTitle": "Mailing helper methods using Microservice validating request body should contain a valid substitution of variables",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an array preceded by a comma when called with parameter isFirst=false",
        "fullTitle": "ArrayStream must return an array preceded by a comma when called with parameter isFirst=false",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit-3 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit-3 items",
        "duration": 28,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit-2 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit-2 items",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit-1 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit-1 items",
        "duration": 19,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+0 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+0 items",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+1 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+1 items",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+2 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+2 items",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+3 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+3 items",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 0 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 0 item(s)",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 1 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 1 item(s)",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 2 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 2 item(s)",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 3 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 3 item(s)",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be fed objects and return them in the callback",
        "fullTitle": "DrainStream must be fed objects and return them in the callback",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error when the provided limit is exceeded",
        "fullTitle": "DrainStream must return an error when the provided limit is exceeded",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return events in accessible streams",
        "fullTitle": "Access permissions Events `get` must only return events in accessible streams",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must return all events when permissions are defined for \"all streams\" (*)",
        "fullTitle": "Access permissions Events `get` must return all events when permissions are defined for \"all streams\" (*)",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return events with accessible tags",
        "fullTitle": "Access permissions Events `get` must only return events with accessible tags",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return events in accessible streams *and* with accessible tags when both are defined",
        "fullTitle": "Access permissions Events `get` must only return events in accessible streams *and* with accessible tags when both are defined",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` (or any request) must alternatively accept the access token in the query string",
        "fullTitle": "Access permissions Events `get` (or any request) must alternatively accept the access token in the query string",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid getting an attached file if permissions are insufficient",
        "fullTitle": "Access permissions Events must forbid getting an attached file if permissions are insufficient",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid creating events for 'read-only' streams",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid creating events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid updating events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid updating events for 'read-only' streams",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid updating events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid updating events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid stopping events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid stopping events for 'read-only' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid stopping events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid stopping events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid deleting events for 'read-only' streams",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid deleting events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creating events for 'contribute' streams",
        "fullTitle": "Access permissions Events must allow creating events for 'contribute' streams",
        "duration": 26,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creating events for 'contribute' tags",
        "fullTitle": "Access permissions Events must allow creating events for 'contribute' tags",
        "duration": 19,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return streams for which permissions are defined",
        "fullTitle": "Access permissions Streams `get` must only return streams for which permissions are defined",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating child streams in 'read-only' streams",
        "fullTitle": "Access permissions Streams must forbid creating child streams in 'read-only' streams",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating child streams in 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid creating child streams in 'contribute' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting child streams in 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid deleting child streams in 'contribute' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid updating 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid updating 'contribute' streams",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid deleting 'contribute' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creating child streams in 'managed' streams",
        "fullTitle": "Access permissions Streams must allow creating child streams in 'managed' streams",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid moving streams into non-'managed' parent streams",
        "fullTitle": "Access permissions Streams must forbid moving streams into non-'managed' parent streams",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow deleting child streams in 'managed' streams",
        "fullTitle": "Access permissions Streams must allow deleting child streams in 'managed' streams",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must recursively apply permissions to the streams' child streams",
        "fullTitle": "Access permissions Streams must recursively apply permissions to the streams' child streams",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow access to all streams when no specific stream permissions are defined",
        "fullTitle": "Access permissions Streams must allow access to all streams when no specific stream permissions are defined",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow access to all streams when only tag permissions are defined",
        "fullTitle": "Access permissions Streams must allow access to all streams when only tag permissions are defined",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only allow access to set streams when both tag and stream permissions are defined",
        "fullTitle": "Access permissions Streams must only allow access to set streams when both tag and stream permissions are defined",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must handle optional caller id in auth (in addition to token)",
        "fullTitle": "Access permissions Auth and change tracking must handle optional caller id in auth (in addition to token)",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be supported and deny access when failing",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must be supported and deny access when failing",
        "duration": 60,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow access when successful",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must allow access when successful",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail properly (i.e. not granting access) when the custom function crashes",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must fail properly (i.e. not granting access) when the custom function crashes",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must validate the custom function at startup time",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must validate the custom function at startup time",
        "duration": 518,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return publicly shared key-value profile info",
        "fullTitle": "profile (app) GET /public must return publicly shared key-value profile info",
        "duration": 55,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return key-value settings for the current app",
        "fullTitle": "profile (app) GET /app must return key-value settings for the current app",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a shared access token",
        "fullTitle": "profile (app) GET /app must refuse requests with a shared access token",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a personal access token",
        "fullTitle": "profile (app) GET /app must refuse requests with a personal access token",
        "duration": 116,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add/update/remove the specified keys without touching the others",
        "fullTitle": "profile (app) PUT /app must add/update/remove the specified keys without touching the others",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a shared access token",
        "fullTitle": "profile (app) PUT /app must refuse requests with a shared access token",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a personal access token",
        "fullTitle": "profile (app) PUT /app must refuse requests with a personal access token",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/public must return publicly shared key-value profile info",
        "fullTitle": "profile (personal) GET /public must return publicly shared key-value profile info",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/private must return private key-value profile info",
        "fullTitle": "profile (personal) GET /private must return private key-value profile info",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an appropriate error for other paths",
        "fullTitle": "profile (personal) GET must return an appropriate error for other paths",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"private\" must be forbidden to non-personal accesses",
        "fullTitle": "profile (personal) GET \"private\" must be forbidden to non-personal accesses",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/public must add/update/remove the specified keys without touching the others",
        "fullTitle": "profile (personal) PUT /public must add/update/remove the specified keys without touching the others",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/private must add/update/remove the specified keys without touching the others",
        "fullTitle": "profile (personal) PUT /private must add/update/remove the specified keys without touching the others",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create the profile if not existing",
        "fullTitle": "profile (personal) PUT must create the profile if not existing",
        "duration": 51,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an appropriate error for other paths",
        "fullTitle": "profile (personal) PUT must return an appropriate error for other paths",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "profile (personal) PUT must be forbidden to non-personal accesses",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the result's content when not storing streams",
        "fullTitle": "Result toObject() must return the result's content when not storing streams",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the result content when storing streams",
        "fullTitle": "Result toObject() must return the result content when storing streams",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error object when attempting to serialize streams containing an amountof objects exceeding the limit",
        "fullTitle": "Result toObject() must return an error object when attempting to serialize streams containing an amountof objects exceeding the limit",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error when storing piped streams",
        "fullTitle": "Result toObject() must return an error when storing piped streams",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error when the core pipeline crashes because of size",
        "fullTitle": "Result toObject() must return an error when the core pipeline crashes because of size",
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return basic server meta information as JSON when requested",
        "fullTitle": "root GET / should return basic server meta information as JSON when requested",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return basic server meta information as text otherwise",
        "fullTitle": "root GET / should return basic server meta information as text otherwise",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an error if trying to access an unknown user account",
        "fullTitle": "root GET / should return an error if trying to access an unknown user account",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return correct common HTTP headers + meta data in response body",
        "fullTitle": "root All requests: should return correct common HTTP headers + meta data in response body",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return meta data in response body for errors as well",
        "fullTitle": "root All requests: should return meta data in response body for errors as well",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should properly translate the Host header's username (i.e. subdomain)",
        "fullTitle": "root All requests: should properly translate the Host header's username (i.e. subdomain)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should translate the username in subdomain also when it only contains numbers",
        "fullTitle": "root All requests: should translate the username in subdomain also when it only contains numbers",
        "duration": 118,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should support POSTing \"urlencoded\" content with _json and _auth fields",
        "fullTitle": "root All requests: should support POSTing \"urlencoded\" content with _json and _auth fields",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should support POSTing \"urlencoded\" content with _json, _method (PUT) and _auth fields",
        "fullTitle": "root All requests: should support POSTing \"urlencoded\" content with _json, _method (PUT) and _auth fields",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should support POSTing \"urlencoded\" content with _json, _method (DELETE) and _auth fields",
        "fullTitle": "root All requests: should support POSTing \"urlencoded\" content with _json, _method (DELETE) and _auth fields",
        "duration": 52,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should properly handle JSON errors when POSTing \"urlencoded\" content with _json field",
        "fullTitle": "root All requests: should properly handle JSON errors when POSTing \"urlencoded\" content with _json field",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should update the access's \"last used\" time and *internal* request counters",
        "fullTitle": "root All requests: should update the access's \"last used\" time and *internal* request counters",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return OK",
        "fullTitle": "root OPTIONS / should return OK",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return current access information",
        "fullTitle": "root GET /access-info must return current access information",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must execute the given method calls and return the results",
        "fullTitle": "root POST / (i.e. batch call) must execute the given method calls and return the results",
        "duration": 76,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must execute the method calls containing events.get and return the results",
        "fullTitle": "root POST / (i.e. batch call) must execute the method calls containing events.get and return the results",
        "duration": 74,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "root POST / (i.e. batch call) must return an error if the sent data is badly formatted",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must dynamically create a namespace for the user",
        "fullTitle": "Socket.IO must dynamically create a namespace for the user",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must connect to a user with a dash in the username",
        "fullTitle": "Socket.IO must connect to a user with a dash in the username",
        "duration": 142,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse connection if no valid access token is provided",
        "fullTitle": "Socket.IO must refuse connection if no valid access token is provided",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly route method call messages for events and return the results, including meta",
        "fullTitle": "Socket.IO calling API methods must properly route method call messages for events and return the results, including meta",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly route method call messages for streams and return the results",
        "fullTitle": "Socket.IO calling API methods must properly route method call messages for streams and return the results",
        "duration": 16,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not crash when callers omit the callback",
        "fullTitle": "Socket.IO calling API methods must not crash when callers omit the callback",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if the called target does not exist",
        "fullTitle": "Socket.IO calling API methods must fail if the called target does not exist",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if the called method does not exist",
        "fullTitle": "Socket.IO calling API methods must fail if the called method does not exist",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return API errors properly, including meta",
        "fullTitle": "Socket.IO calling API methods must return API errors properly, including meta",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must notify other sockets for the same user about events changes",
        "fullTitle": "Socket.IO calling API methods must notify other sockets for the same user about events changes",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must notify other sockets for the same user (only) about streams changes",
        "fullTitle": "Socket.IO calling API methods must notify other sockets for the same user (only) about streams changes",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must notify on each change",
        "fullTitle": "Socket.IO calling API methods must notify on each change",
        "duration": 64,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "changes made in A notify clients of B",
        "fullTitle": "Socket.IO when spawning 2 api-server processes, A and B changes made in A notify clients of B",
        "duration": 119,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return non-trashed streams (as a tree) by default",
        "fullTitle": "streams GET / must return non-trashed streams (as a tree) by default",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all streams (trashed or not) when requested",
        "fullTitle": "streams GET / must return all streams (trashed or not) when requested",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must include stream deletions (since the given time) when requested",
        "fullTitle": "streams GET / must include stream deletions (since the given time) when requested",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must include stream deletions even when the given time is 0",
        "fullTitle": "streams GET / must include stream deletions even when the given time is 0",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not keep stream deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "fullTitle": "streams GET / must not keep stream deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 401 error if no access token is provided",
        "fullTitle": "streams GET / must return a correct 401 error if no access token is provided",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return child streams when providing a parent stream id",
        "fullTitle": "streams GET / must return child streams when providing a parent stream id",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the parent stream is unknown",
        "fullTitle": "streams GET / must return a correct error if the parent stream is unknown",
        "duration": 19,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new \"root\" stream with the sent data, returning it",
        "fullTitle": "streams POST / must create a new \"root\" stream with the sent data, returning it",
        "duration": 39,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "streams POST / must return a correct error if the sent data is badly formatted",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if a stream with the same id already exists",
        "fullTitle": "streams POST / must return a correct error if a stream with the same id already exists",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow reuse of deleted ids",
        "fullTitle": "streams POST / must allow reuse of deleted ids",
        "duration": 45,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "streams POST / must accept explicit null for optional fields",
        "duration": 28,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if a sibling stream with the same name already exists",
        "fullTitle": "streams POST / must fail if a sibling stream with the same name already exists",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is not valid JSON",
        "fullTitle": "streams POST / must return a correct error if the sent data is not valid JSON",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new child stream (with predefined id) when providing a parent stream id",
        "fullTitle": "streams POST / must create a new child stream (with predefined id) when providing a parent stream id",
        "duration": 31,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the new stream's parentId is the empty string",
        "fullTitle": "streams POST / must return an error if the new stream's parentId is the empty string",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must slugify the new stream's predefined id",
        "fullTitle": "streams POST / must slugify the new stream's predefined id",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the parent stream is unknown",
        "fullTitle": "streams POST / must return a correct error if the parent stream is unknown",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the given predefined stream's id is \"null\"",
        "fullTitle": "streams POST / must return a correct error if the given predefined stream's id is \"null\"",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the given predefined stream's id is \"*\"",
        "fullTitle": "streams POST / must return a correct error if the given predefined stream's id is \"*\"",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the stream with the sent data",
        "fullTitle": "streams PUT /<id> must modify the stream with the sent data",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "streams PUT /<id> must accept explicit null for optional fields",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add/update/remove the specified client data fields without touching the others",
        "fullTitle": "streams PUT /<id> must add/update/remove the specified client data fields without touching the others",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the stream does not exist",
        "fullTitle": "streams PUT /<id> must return a correct error if the stream does not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "streams PUT /<id> must return a correct error if the sent data is badly formatted",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if a sibling stream with the same name already exists",
        "fullTitle": "streams PUT /<id> must fail if a sibling stream with the same name already exists",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must move the stream under the given parent when specified",
        "fullTitle": "streams PUT /<id> must move the stream under the given parent when specified",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the new parent stream is unknown",
        "fullTitle": "streams PUT /<id> must return a correct error if the new parent stream is unknown",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail and throw a forbidden error in strict mode",
        "fullTitle": "streams PUT /<id> forbidden updates of protected fields must fail and throw a forbidden error in strict mode",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must succeed by ignoring protected fields and log a warning in non-strict mode",
        "fullTitle": "streams PUT /<id> forbidden updates of protected fields must succeed by ignoring protected fields and log a warning in non-strict mode",
        "duration": 1287,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must flag the specified stream as trashed",
        "fullTitle": "streams DELETE /<id> must flag the specified stream as trashed",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the stream when already trashed with its descendants if there are no linked events",
        "fullTitle": "streams DELETE /<id> must delete the stream when already trashed with its descendants if there are no linked events",
        "duration": 56,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if there are linked events and the related parameter is missing",
        "fullTitle": "streams DELETE /<id> must return a correct error if there are linked events and the related parameter is missing",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reject the deletion of a root stream with mergeEventsWithParent=true",
        "fullTitle": "streams DELETE /<id> must reject the deletion of a root stream with mergeEventsWithParent=true",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reassign the linked events to the deleted stream's parent when specified",
        "fullTitle": "streams DELETE /<id> must reassign the linked events to the deleted stream's parent when specified",
        "duration": 56,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the linked events when mergeEventsWithParent is false",
        "fullTitle": "streams DELETE /<id> must delete the linked events when mergeEventsWithParent is false",
        "duration": 133,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the item is unknown",
        "fullTitle": "streams DELETE /<id> must return a correct error if the item is unknown",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not send a welcome email if mailing is deactivated",
        "fullTitle": "system (ex-register) POST /create-user must not send a welcome email if mailing is deactivated",
        "duration": 1345,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not send a welcome email if welcome mail is deactivated",
        "fullTitle": "system (ex-register) POST /create-user must not send a welcome email if welcome mail is deactivated",
        "duration": 1350,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new user with the sent data, sending a welcome email",
        "fullTitle": "system (ex-register) POST /create-user when email sending really works must create a new user with the sent data, sending a welcome email",
        "duration": 1348,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must run the process but not save anything for test username \"recla\"",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must run the process but not save anything for test username \"recla\"",
        "duration": 1239,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must support the old \"/register\" path for backwards-compatibility",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must support the old \"/register\" path for backwards-compatibility",
        "duration": 65,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if the sent data is badly formatted",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if the sent data is badly formatted",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if the language property is above 5 characters",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if the language property is above 5 characters",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if the language property is the empty string",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if the language property is the empty string",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if a user with the same user name already exists",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if a user with the same user name already exists",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if a user with the same email address already exists",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if a user with the same email address already exists",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 404 error when authentication is invalid",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 404 error when authentication is invalid",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the content type is wrong",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct error if the content type is wrong",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must replace the passwordHash in the logs by (hidden) when the authentication is invalid",
        "fullTitle": "system (ex-register) POST /create-user when we log into a temporary log file must replace the passwordHash in the logs by (hidden) when the authentication is invalid",
        "duration": 27,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must replace the passwordHash in the logs by (hidden) when the payload is invalid (here parameters)",
        "fullTitle": "system (ex-register) POST /create-user when we log into a temporary log file must replace the passwordHash in the logs by (hidden) when the payload is invalid (here parameters)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not mention the passwordHash in the logs when none is provided",
        "fullTitle": "system (ex-register) POST /create-user when we log into a temporary log file must not mention the passwordHash in the logs when none is provided",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return user information (including time of last account use)",
        "fullTitle": "system (ex-register) GET /user-info/{username} must return user information (including time of last account use)",
        "duration": 84,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 404 error when authentication is invalid",
        "fullTitle": "system (ex-register) GET /user-info/{username} must return a correct 404 error when authentication is invalid",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should parse file uploads",
        "fullTitle": "uploads middleware hasFileUpload should parse file uploads",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #serverReady notifies internal listeners",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #serverReady notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #accountChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #accountChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #accessesChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #accessesChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #followedSlicesChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #followedSlicesChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #streamsChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #streamsChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #eventsChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #eventsChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns true if all properties exist",
        "fullTitle": "Authentication hasProperties returns true if all properties exist",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns false if not all properties exist",
        "fullTitle": "Authentication hasProperties returns false if not all properties exist",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns false if null is given",
        "fullTitle": "Authentication hasProperties returns false if null is given",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns false if a string is given",
        "fullTitle": "Authentication hasProperties returns false if a string is given",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should behave as documented in the method",
        "fullTitle": "tryCoerceStringValues should behave as documented in the method",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "doesn't create keys in object",
        "fullTitle": "tryCoerceStringValues doesn't create keys in object",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should convert to array",
        "fullTitle": "tryCoerceStringValues should convert to array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "number conversion works",
        "fullTitle": "tryCoerceStringValues number conversion works",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should construct",
        "fullTitle": "NatsPublisher should construct",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "delivers messages to \"USERNAME.sok1\"",
        "fullTitle": "NatsPublisher delivers messages to \"USERNAME.sok1\"",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should construct",
        "fullTitle": "NatsSubscriber should construct",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "accepts messages from USERNAME.sok1 and dispatches them to sinks",
        "fullTitle": "NatsSubscriber when subscribed to \"foobar\" subscribe(\"USERNAME\") accepts messages from USERNAME.sok1 and dispatches them to sinks",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "ignores messages from other users",
        "fullTitle": "NatsSubscriber when subscribed to \"foobar\" subscribe(\"USERNAME\") ignores messages from other users",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should unsubscribe from NATS",
        "fullTitle": "NatsSubscriber when subscribed to \"foobar\" unsubscribe() should unsubscribe from NATS",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [
      {
        "title": "must delete history data from the storage",
        "fullTitle": "Auditing Nightly task must delete history data from the storage",
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not keep event deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "fullTitle": "events GET / must not keep event deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error when the core pipeline crashes because of size",
        "fullTitle": "Result toObject() must return an error when the core pipeline crashes because of size",
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not keep stream deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "fullTitle": "streams GET / must not keep stream deletions past a certain time (cannot test because cannot force-run Mongo's TTL cleanup task)",
        "currentRetry": 0,
        "err": {}
      }
    ],
    "failures": [],
    "passes": [
      {
        "title": "should contain deletions",
        "fullTitle": "access deletions when given a few existing accesses accesses.get should contain deletions",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains active accesses",
        "fullTitle": "access deletions when given a few existing accesses accesses.get contains active accesses",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains deleted accesses as well",
        "fullTitle": "access deletions when given a few existing accesses accesses.get contains deleted accesses as well",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "deleted access are in UTC (seconds) format",
        "fullTitle": "access deletions when given a few existing accesses accesses.get deleted access are in UTC (seconds) format",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain an access",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a valid access should contain an access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain the set values, but no \"deleted\" field in the API response",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a valid access should contain the set values, but no \"deleted\" field in the API response",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain the field \"deleted:null\" in the database",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a valid access should contain the field \"deleted:null\" in the database",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an error",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a deleted access should return an error",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "error should say that the deleted field is forbidden upon creation",
        "fullTitle": "access deletions when given a few existing accesses accesses.create for a deleted access error should say that the deleted field is forbidden upon creation",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an error",
        "fullTitle": "access deletions when given a few existing accesses accesses.update should return an error",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "error should say that the deleted field is forbidden upon update",
        "fullTitle": "access deletions when given a few existing accesses accesses.update error should say that the deleted field is forbidden upon update",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access expiry when given a few existing accesses accesses.get vanilla version succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains only active accesses",
        "fullTitle": "access expiry when given a few existing accesses accesses.get vanilla version contains only active accesses",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access expiry when given a few existing accesses accesses.get when given the includeExpired=true parameter succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "includes expired accesses",
        "fullTitle": "access expiry when given a few existing accesses accesses.get when given the includeExpired=true parameter includes expired accesses",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an access with set expiry timestamp",
        "fullTitle": "access expiry when given a few existing accesses accesses.create when called with expireAfter>0 creates an access with set expiry timestamp",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an expired access",
        "fullTitle": "access expiry when given a few existing accesses accesses.create when called with expireAfter=0 creates an expired access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "access expiry when given a few existing accesses accesses.create when called with expireAfter<0 fails",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "sets the 'expires' attribute",
        "fullTitle": "access expiry when given a few existing accesses accesses.update with expireAfter>0 sets the 'expires' attribute",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "expires the access immediately",
        "fullTitle": "access expiry when given a few existing accesses accesses.update with expireAfter=0 expires the access immediately",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "removes expiry",
        "fullTitle": "access expiry when given a few existing accesses accesses.update with expires=null removes expiry",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "access expiry when given a few existing accesses accesses.update when trying to update itself with a longer expiration fails",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the matching access",
        "fullTitle": "access expiry when given a few existing accesses accesses.checkApp when the matching access is not expired returns the matching access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns no match",
        "fullTitle": "access expiry when given a few existing accesses accesses.checkApp when the matching access is expired returns no match",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "access expiry when given a few existing accesses other API accesses using an expired access fails",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns a proper error message",
        "fullTitle": "access expiry when given a few existing accesses other API accesses using an expired access returns a proper error message",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access expiry when given a few existing accesses other API accesses using a valid access succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "access client data when given a few existing accesses accesses.get succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains existing accesses with clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.get contains existing accesses with clientData",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an access with empty clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.create when called with clientData={} creates an access with empty clientData",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws a schema error",
        "fullTitle": "access client data when given a few existing accesses accesses.create when called with clientData=null throws a schema error",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "creates an access with complex clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.create when called with complex clientData creates an access with complex clientData",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "updates previous clientData with new clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.update if existing clientData was not empty updates previous clientData with new clientData",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "keeps existing clientData untouched",
        "fullTitle": "access client data when given a few existing accesses accesses.update if clientData is not provided keeps existing clientData untouched",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "sets clientData to provided clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.update if existing clientData was empty sets clientData to provided clientData",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "removes existing clientData",
        "fullTitle": "access client data when given a few existing accesses accesses.update if provided clientData is explicitely null removes existing clientData",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the matching access",
        "fullTitle": "access client data when given a few existing accesses accesses.checkApp when the provided clientData matches the existing clientData returns the matching access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns no match",
        "fullTitle": "access client data when given a few existing accesses accesses.checkApp when the provided clientData does not match the existing clientData returns no match",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns no match",
        "fullTitle": "access client data when given a few existing accesses accesses.checkApp when no clientData is provided but existing access has one returns no match",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "users pool create pool user succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "contains a generated pool user id",
        "fullTitle": "users pool create pool user contains a generated pool user id",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "created a user in the database",
        "fullTitle": "users pool create pool user created a user in the database",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "created the related collections",
        "fullTitle": "users pool create pool user created the related collections",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "created the related indexes",
        "fullTitle": "users pool create pool user created the related indexes",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must succeed",
        "fullTitle": "users pool get pool size when empty must succeed",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return 0",
        "fullTitle": "users pool get pool size when empty must return 0",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "succeeds",
        "fullTitle": "users pool get pool size when adding pool users succeeds",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "has the right number of pool users",
        "fullTitle": "users pool get pool size when adding pool users has the right number of pool users",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return shared accesses whose permissions are a subset of the current one's",
        "fullTitle": "accesses (app) GET / must return shared accesses whose permissions are a subset of the current one's",
        "duration": 67,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to requests with a shared access token",
        "fullTitle": "accesses (app) GET / must be forbidden to requests with a shared access token",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new shared access with the sent data and return it",
        "fullTitle": "accesses (app) POST / must create a new shared access with the sent data and return it",
        "duration": 43,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to create a non-shared access",
        "fullTitle": "accesses (app) POST / must forbid trying to create a non-shared access",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to create an access with greater permissions",
        "fullTitle": "accesses (app) POST / must forbid trying to create an access with greater permissions",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "accesses (app) POST / must return a correct error if the sent data is badly formatted",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creation of shared accesses with an access that has superior permission on root stream (*)",
        "fullTitle": "accesses (app) POST / must allow creation of shared accesses with an access that has superior permission on root stream (*)",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the access with the sent data",
        "fullTitle": "accesses (app) PUT /<token> must modify the access with the sent data",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to modify a non-shared access",
        "fullTitle": "accesses (app) PUT /<token> must forbid trying to modify a non-shared access",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to modify an access with greater permissions",
        "fullTitle": "accesses (app) PUT /<token> must forbid trying to modify an access with greater permissions",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the access does not exist",
        "fullTitle": "accesses (app) PUT /<token> must return a correct error if the access does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "accesses (app) PUT /<token> must return a correct error if the sent data is badly formatted",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if an access with the same name already exists",
        "fullTitle": "accesses (app) PUT /<token> must return a correct error if an access with the same name already exists",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the shared access",
        "fullTitle": "accesses (app) DELETE /<token> must delete the shared access",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to delete a non-shared access",
        "fullTitle": "accesses (app) DELETE /<token> must forbid trying to delete a non-shared access",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid trying to delete an access with greater permissions",
        "fullTitle": "accesses (app) DELETE /<token> must forbid trying to delete an access with greater permissions",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the access does not exist",
        "fullTitle": "accesses (app) DELETE /<token> must return a correct error if the access does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all accesses (including personal ones)",
        "fullTitle": "accesses (personal) GET / must return all accesses (including personal ones)",
        "duration": 13,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new shared access with the sent data, returning it",
        "fullTitle": "accesses (personal) POST / must create a new shared access with the sent data, returning it",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new app access with the sent data, creating/restoring requested streams",
        "fullTitle": "accesses (personal) POST / must create a new app access with the sent data, creating/restoring requested streams",
        "duration": 79,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept two app accesses with the same name (app ids) but different device names",
        "fullTitle": "accesses (personal) POST / must accept two app accesses with the same name (app ids) but different device names",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must ignore erroneous requests to create new streams",
        "fullTitle": "accesses (personal) POST / must ignore erroneous requests to create new streams",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if a stream similar to that requested for creation already exists",
        "fullTitle": "accesses (personal) POST / must fail if a stream similar to that requested for creation already exists",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse to create new personal accesses (obtained via login only)",
        "fullTitle": "accesses (personal) POST / must refuse to create new personal accesses (obtained via login only)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must slugify the new access' predefined token",
        "fullTitle": "accesses (personal) POST / must slugify the new access' predefined token",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "accesses (personal) POST / must return an error if the sent data is badly formatted",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse empty `defaultName` values for streams",
        "fullTitle": "accesses (personal) POST / must refuse empty `defaultName` values for streams",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an access with the same token already exists",
        "fullTitle": "accesses (personal) POST / must return an error if an access with the same token already exists",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an access with the same name already exists",
        "fullTitle": "accesses (personal) POST / must return an error if an access with the same name already exists",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an \"app\" access with the same name (app id) and device name already exists",
        "fullTitle": "accesses (personal) POST / must return an error if an \"app\" access with the same name (app id) and device name already exists",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the device name is set for a non-app access",
        "fullTitle": "accesses (personal) POST / must return an error if the device name is set for a non-app access",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the given predefined access's token is a reserved word",
        "fullTitle": "accesses (personal) POST / must return an error if the given predefined access's token is a reserved word",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the shared access with the sent data",
        "fullTitle": "accesses (personal) PUT /<token> must modify the shared access with the sent data",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the personal access with the specified data",
        "fullTitle": "accesses (personal) PUT /<token> must modify the personal access with the specified data",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the access does not exist",
        "fullTitle": "accesses (personal) PUT /<token> must return an error if the access does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "accesses (personal) PUT /<token> must return an error if the sent data is badly formatted",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if an access with the same name and type already exists",
        "fullTitle": "accesses (personal) PUT /<token> must return an error if an access with the same name and type already exists",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and throw a forbidden error in strict mode",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must prevent update of protected fields and throw a forbidden error in strict mode",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and log a warning in non-strict mode",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must prevent update of protected fields and log a warning in non-strict mode",
        "duration": 1144,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid to elevate a read level into a manage level using a contribute access ",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must forbid to elevate a read level into a manage level using a contribute access ",
        "duration": 62,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid to extend the permission streamIds beyond the authorized context ",
        "fullTitle": "accesses (personal) PUT /<token> forbidden updates of protected fields must forbid to extend the permission streamIds beyond the authorized context ",
        "duration": 62,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the shared access",
        "fullTitle": "accesses (personal) DELETE /<token> must delete the shared access",
        "duration": 33,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the personal access",
        "fullTitle": "accesses (personal) DELETE /<token> must delete the personal access",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the access does not exist",
        "fullTitle": "accesses (personal) DELETE /<token> must return an error if the access does not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the adjusted permissions structure if no access exists",
        "fullTitle": "accesses (personal) POST /check-app must return the adjusted permissions structure if no access exists",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept requested permissions with \"*\" for \"all streams\"",
        "fullTitle": "accesses (personal) POST /check-app must accept requested permissions with \"*\" for \"all streams\"",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the existing app access if matching",
        "fullTitle": "accesses (personal) POST /check-app must return the existing app access if matching",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must also return the token of the existing mismatching access if any",
        "fullTitle": "accesses (personal) POST /check-app must also return the token of the existing mismatching access if any",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must propose fixes to duplicate ids of streams and signal an error when appropriate",
        "fullTitle": "accesses (personal) POST /check-app must propose fixes to duplicate ids of streams and signal an error when appropriate",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "accesses (personal) POST /check-app must return an error if the sent data is badly formatted",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "accesses (personal) POST /check-app must be forbidden to non-personal accesses",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the user's account details",
        "fullTitle": "account GET / must return the user's account details",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "account GET / must be forbidden to non-personal accesses",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify account details with the sent data, notifying register if e-mail changed",
        "fullTitle": "account PUT / must modify account details with the sent data, notifying register if e-mail changed",
        "duration": 1237,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "account PUT / must return a correct error if the sent data is badly formatted",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "account PUT / must be forbidden to non-personal accesses",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly compute used storage size for a given user when called",
        "fullTitle": "account storage space monitoring must properly compute used storage size for a given user when called",
        "duration": 133,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly compute storage size for all users in nightly script",
        "fullTitle": "account storage space monitoring must properly compute storage size for all users in nightly script",
        "duration": 1114,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be approximately updated (diff) when adding an attached file",
        "fullTitle": "account storage space monitoring must be approximately updated (diff) when adding an attached file",
        "duration": 47,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be approximately updated (diff) when deleting an attached file",
        "fullTitle": "account storage space monitoring must be approximately updated (diff) when deleting an attached file",
        "duration": 51,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be approximately updated (diff) when deleting an event",
        "fullTitle": "account storage space monitoring must be approximately updated (diff) when deleting an event",
        "duration": 77,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must change the password to the given value",
        "fullTitle": "account /change-password must change the password to the given value",
        "duration": 278,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the given old password does not match",
        "fullTitle": "account /change-password must return an error if the given old password does not match",
        "duration": 89,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "account /change-password must return a correct error if the sent data is badly formatted",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "account /change-password must be forbidden to non-personal accesses",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"request\" must trigger an email with a reset token, store that token, then \"reset\" must reset the password to the given value",
        "fullTitle": "account /request-password-reset and /reset-password \"request\" must trigger an email with a reset token, store that token, then \"reset\" must reset the password to the given value",
        "duration": 1475,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not trigger a reset email if mailing is deactivated",
        "fullTitle": "account /request-password-reset and /reset-password must not trigger a reset email if mailing is deactivated",
        "duration": 1214,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not trigger a reset email if reset mail is deactivated",
        "fullTitle": "account /request-password-reset and /reset-password must not trigger a reset email if reset mail is deactivated",
        "duration": 1206,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not be possible to use a reset token to illegally change password of another user",
        "fullTitle": "account /request-password-reset and /reset-password must not be possible to use a reset token to illegally change password of another user",
        "duration": 27,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"request\" must return an error if the requesting app is not trusted",
        "fullTitle": "account /request-password-reset and /reset-password \"request\" must return an error if the requesting app is not trusted",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"request\" must return an error if sent data is badly formatted",
        "fullTitle": "account /request-password-reset and /reset-password \"request\" must return an error if sent data is badly formatted",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"reset\" must return an error if the reset token is invalid/expired",
        "fullTitle": "account /request-password-reset and /reset-password \"reset\" must return an error if the reset token is invalid/expired",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"reset\" must return an error if the requesting app is not trusted",
        "fullTitle": "account /request-password-reset and /reset-password \"reset\" must return an error if the requesting app is not trusted",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"reset\" must return an error if sent data is badly formatted",
        "fullTitle": "account /request-password-reset and /reset-password \"reset\" must return an error if sent data is badly formatted",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not return history when calling events.get",
        "fullTitle": "Auditing Events must not return history when calling events.get",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the event's history when deleting it with deletionMode=keep-nothing",
        "fullTitle": "Auditing Events deletionMode must delete the event's history when deleting it with deletionMode=keep-nothing",
        "duration": 1165,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must minimize the event's history when deleting it with deletionMode=keep-authors",
        "fullTitle": "Auditing Events deletionMode must minimize the event's history when deleting it with deletionMode=keep-authors",
        "duration": 1152,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not modify the event's history when deleting it with deletionMode=keep-everything",
        "fullTitle": "Auditing Events deletionMode must not modify the event's history when deleting it with deletionMode=keep-everything",
        "duration": 1137,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not return an event's history when calling getOne with includeHistory flag off",
        "fullTitle": "Auditing Events getOne must not return an event's history when calling getOne with includeHistory flag off",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an event's history when calling getOne with includeHistory flag on",
        "fullTitle": "Auditing Events getOne must return an event's history when calling getOne with includeHistory flag on",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when updating an event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history when updating an event",
        "duration": 138,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history of the running event that was stopped because of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history of the running event that was stopped because of the start call on another event",
        "duration": 65,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when no event was stopped in the procedure of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history when no event was stopped in the procedure of the start call on another event",
        "duration": 44,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when calling stop on a running event",
        "fullTitle": "Auditing Events forceKeepHistory is OFF must not generate history when calling stop on a running event",
        "duration": 46,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate history when updating an event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must generate history when updating an event",
        "duration": 178,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate history of the running event that was stopped because of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must generate history of the running event that was stopped because of the start call on another event",
        "duration": 74,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not generate history when no event was stopped in the procedure of the start call on another event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must not generate history when no event was stopped in the procedure of the start call on another event",
        "duration": 39,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate history when calling stop on a running event",
        "fullTitle": "Auditing Events forceKeepHistory is ON must generate history when calling stop on a running event",
        "duration": 53,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must generate events' history when their stream is deleted with  mergeEventsWithParents=true since their streamId is modified",
        "fullTitle": "Auditing Streams must generate events' history when their stream is deleted with  mergeEventsWithParents=true since their streamId is modified",
        "duration": 135,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-nothing'",
        "fullTitle": "Auditing Streams must delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-nothing'",
        "duration": 1172,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must keep the events' minimal history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-authors'",
        "fullTitle": "Auditing Streams must keep the events' minimal history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-authors'",
        "duration": 1173,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-everything'",
        "fullTitle": "Auditing Streams must not delete the events' history when their stream is deleted with  mergeEventsWithParents=false and deletionMode='keep-everything'",
        "duration": 1149,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must authenticate the given credentials, open a session and return the access token",
        "fullTitle": "auth /login must authenticate the given credentials, open a session and return the access token",
        "duration": 165,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reuse the current session if already open",
        "fullTitle": "auth /login must reuse the current session if already open",
        "duration": 199,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept \"wildcarded\" app ids and origins",
        "fullTitle": "auth /login must accept \"wildcarded\" app ids and origins",
        "duration": 100,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept \"no origin\" (i.e. not a CORS request) if authorized",
        "fullTitle": "auth /login must accept \"no origin\" (i.e. not a CORS request) if authorized",
        "duration": 120,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "fullTitle": "auth /login must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "duration": 97,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "fullTitle": "auth /login must also accept \"referer\" in place of \"origin\" (e.g. some browsers do not provide \"origin\")",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not be case-sensitive for the username",
        "fullTitle": "auth /login must not be case-sensitive for the username",
        "duration": 103,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error when the local credentials are missing or invalid",
        "fullTitle": "auth /login must return a correct error when the local credentials are missing or invalid",
        "duration": 81,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the app id is missing or untrusted",
        "fullTitle": "auth /login must return a correct error if the app id is missing or untrusted",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the origin is missing or does not match the app id",
        "fullTitle": "auth /login must return a correct error if the origin is missing or does not match the app id",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must support concurrent login request",
        "fullTitle": "auth /login must support concurrent login request",
        "duration": 126,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not leak _private object from Result",
        "fullTitle": "auth /login must not leak _private object from Result",
        "duration": 95,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must replace the password in the logs by (hidden) when an error occurs",
        "fullTitle": "auth /login when we log into a temporary log file must replace the password in the logs by (hidden) when an error occurs",
        "duration": 144,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not mention the password in the logs when none is provided",
        "fullTitle": "auth /login when we log into a temporary log file must not mention the password in the logs when none is provided",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must terminate the access session and fail to logout a second time (session already expired)",
        "fullTitle": "auth /logout must terminate the access session and fail to logout a second time (session already expired)",
        "duration": 219,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "(or any request) must alternatively accept the access token in the query string",
        "fullTitle": "auth /logout (or any request) must alternatively accept the access token in the query string",
        "duration": 148,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "GET /who-am-i must return a 404 as it has been deprecated",
        "fullTitle": "auth SSO support GET /who-am-i must return a 404 as it has been deprecated",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must set the SSO cookie on /login with the access token",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must set the SSO cookie on /login with the access token",
        "duration": 160,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must answer /who-am-i with username and session details if session open",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must answer /who-am-i with username and session details if session open",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must clear the SSO cookie on /logout",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must clear the SSO cookie on /logout",
        "duration": 42,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must respond /who-am-i with an \"unauthorized\" error if no cookie is sent",
        "fullTitle": "auth SSO support when deprecated.auth.ssoIsWhoamiActivated is set must respond /who-am-i with an \"unauthorized\" error if no cookie is sent",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the last 20 non-trashed events (sorted descending) by default",
        "fullTitle": "events GET / must return the last 20 non-trashed events (sorted descending) by default",
        "duration": 91,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events for the given streams (incl. sub-streams) when set",
        "fullTitle": "events GET / must only return events for the given streams (incl. sub-streams) when set",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if some of the given streams do not exist",
        "fullTitle": "events GET / must return an error if some of the given streams do not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events with the given tag when set",
        "fullTitle": "events GET / must only return events with the given tag when set",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events with any of the given tags when set",
        "fullTitle": "events GET / must only return events with any of the given tags when set",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events of any of the given types when set",
        "fullTitle": "events GET / must only return events of any of the given types when set",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must (unofficially) support a wildcard for event types",
        "fullTitle": "events GET / must (unofficially) support a wildcard for event types",
        "duration": 38,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events in the given time period sorted ascending when set",
        "fullTitle": "events GET / must only return events in the given time period sorted ascending when set",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must take into account fromTime and toTime even if set to 0",
        "fullTitle": "events GET / must take into account fromTime and toTime even if set to 0",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must take into account modifiedSince even if set to 0",
        "fullTitle": "events GET / must take into account modifiedSince even if set to 0",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly exclude period events completed before the given period",
        "fullTitle": "events GET / must properly exclude period events completed before the given period",
        "duration": 40,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return ongoing events started before the given time period",
        "fullTitle": "events GET / must return ongoing events started before the given time period",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return events in the given paging range when set",
        "fullTitle": "events GET / must only return events in the given paging range when set",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return only trashed events when requested",
        "fullTitle": "events GET / must return only trashed events when requested",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all events (trashed or not) when requested",
        "fullTitle": "events GET / must return all events (trashed or not) when requested",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return only events modified since the given time when requested",
        "fullTitle": "events GET / must return only events modified since the given time when requested",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must include event deletions (since that time) when requested",
        "fullTitle": "events GET / must include event deletions (since that time) when requested",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only return running period event(s) when requested",
        "fullTitle": "events GET / must only return running period event(s) when requested",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if no access token is provided",
        "fullTitle": "events GET / must return an error if no access token is provided",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the attached file with the correct headers",
        "fullTitle": "events GET /<event id>/<file id> must return the attached file with the correct headers",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept a secure read token in the query string instead of the `\"Authorization\" header",
        "fullTitle": "events GET /<event id>/<file id> must accept a secure read token in the query string instead of the `\"Authorization\" header",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow a filename path suffix after the file id",
        "fullTitle": "events GET /<event id>/<file id> must allow a filename path suffix after the file id",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow any filename (including special characters)",
        "fullTitle": "events GET /<event id>/<file id> must allow any filename (including special characters)",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse an invalid file read token",
        "fullTitle": "events GET /<event id>/<file id> must refuse an invalid file read token",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse auth via the regular \"auth\" query string parameter",
        "fullTitle": "events GET /<event id>/<file id> must refuse auth via the regular \"auth\" query string parameter",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if trying to get an unknown attachment",
        "fullTitle": "events GET /<event id>/<file id> must return a proper error if trying to get an unknown attachment",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create an event with the sent data, returning it",
        "fullTitle": "events POST / must create an event with the sent data, returning it",
        "duration": 39,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must set the event's time to \"now\" if missing",
        "fullTitle": "events POST / must set the event's time to \"now\" if missing",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "events POST / must accept explicit null for optional fields",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse events with no stream id",
        "fullTitle": "events POST / must refuse events with no stream id",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if an event with the same id already exists",
        "fullTitle": "events POST / must return a correct error if an event with the same id already exists",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not allow reuse of deleted ids (unlike streams)",
        "fullTitle": "events POST / must not allow reuse of deleted ids (unlike streams)",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only allow ids that are formatted like cuids",
        "fullTitle": "events POST / must only allow ids that are formatted like cuids",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reject tags that are too long",
        "fullTitle": "events POST / must reject tags that are too long",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fix the tags to an empty array if not set",
        "fullTitle": "events POST / must fix the tags to an empty array if not set",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must try casting string event content to number if appropriate",
        "fullTitle": "events POST / must try casting string event content to number if appropriate",
        "duration": 38,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not stop the running period event if the new event is a mark event (single activity)",
        "fullTitle": "events POST / must not stop the running period event if the new event is a mark event (single activity)",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not stop the running period event if the stream allows overlapping",
        "fullTitle": "events POST / must not stop the running period event if the stream allows overlapping",
        "duration": 43,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must validate the event's content if its type is known",
        "fullTitle": "events POST / must validate the event's content if its type is known",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not fail when validating the content if passing a string instead of an object",
        "fullTitle": "events POST / must not fail when validating the content if passing a string instead of an object",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "events POST / must return an error if the sent data is badly formatted",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the associated stream is unknown",
        "fullTitle": "events POST / must return an error if the associated stream is unknown",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the event's period overlaps existing periods (single activity)",
        "fullTitle": "events POST / must return an error if the event's period overlaps existing periods (single activity)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow the event's period overlapping existing periods when the stream allows it",
        "fullTitle": "events POST / must allow the event's period overlapping existing periods when the stream allows it",
        "duration": 31,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the assigned stream is trashed",
        "fullTitle": "events POST / must return an error if the assigned stream is trashed",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not fail (500) when sending an array instead of an object",
        "fullTitle": "events POST / must not fail (500) when sending an array instead of an object",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a running period event stopping any previously running event (single activity)",
        "fullTitle": "events POST /start must create a running period event stopping any previously running event (single activity)",
        "duration": 51,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if a period event already exists later (single activity)",
        "fullTitle": "events POST /start must return an error if a period event already exists later (single activity)",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow starting an event before an existing period when the stream allows overlapping",
        "fullTitle": "events POST /start must allow starting an event before an existing period when the stream allows overlapping",
        "duration": 33,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new event with the uploaded files",
        "fullTitle": "events POST / (multipart content) must create a new event with the uploaded files",
        "duration": 95,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly handle part names containing special chars (e.g. \".\", \"$\")",
        "fullTitle": "events POST / (multipart content) must properly handle part names containing special chars (e.g. \".\", \"$\")",
        "duration": 70,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the non-file content part is not JSON",
        "fullTitle": "events POST / (multipart content) must return an error if the non-file content part is not JSON",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if there is more than one non-file content part",
        "fullTitle": "events POST / (multipart content) must return an error if there is more than one non-file content part",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add the uploaded files to the event as attachments",
        "fullTitle": "events POST /<event id> (multipart content) must add the uploaded files to the event as attachments",
        "duration": 71,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add the uploaded files to the event without replacing existing attachments",
        "fullTitle": "events POST /<event id> (multipart content) must add the uploaded files to the event without replacing existing attachments",
        "duration": 58,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "allows access at level=read",
        "fullTitle": "events GET /<id> allows access at level=read",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "denies access without authorization",
        "fullTitle": "events GET /<id> denies access without authorization",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the event with the sent data",
        "fullTitle": "events PUT /<id> must modify the event with the sent data",
        "duration": 38,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add/update/remove the specified client data fields without touching the others",
        "fullTitle": "events PUT /<id> must add/update/remove the specified client data fields without touching the others",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the id of the stopped previously running event if any (single activity)",
        "fullTitle": "events PUT /<id> must return the id of the stopped previously running event if any (single activity)",
        "duration": 45,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "events PUT /<id> must accept explicit null for optional fields",
        "duration": 44,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must validate the event's content if its type is known",
        "fullTitle": "events PUT /<id> must validate the event's content if its type is known",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the event does not exist",
        "fullTitle": "events PUT /<id> must return an error if the event does not exist",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "events PUT /<id> must return an error if the sent data is badly formatted",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the associated stream is unknown",
        "fullTitle": "events PUT /<id> must return an error if the associated stream is unknown",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if moving a running period event before another existing period event (single activity)",
        "fullTitle": "events PUT /<id> must return an error if moving a running period event before another existing period event (single activity)",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the event's new period overlaps other events's (single activity)",
        "fullTitle": "events PUT /<id> must return an error if the event's new period overlaps other events's (single activity)",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reject tags that are too long",
        "fullTitle": "events PUT /<id> must reject tags that are too long",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and throw a forbidden error in strict mode",
        "fullTitle": "events PUT /<id> forbidden updates of protected fields must prevent update of protected fields and throw a forbidden error in strict mode",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must prevent update of protected fields and log a warning in non-strict mode",
        "fullTitle": "events PUT /<id> forbidden updates of protected fields must prevent update of protected fields and log a warning in non-strict mode",
        "duration": 1148,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must stop the previously running period event, returning its id (single activity)",
        "fullTitle": "events POST /stop must stop the previously running period event, returning its id (single activity)",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must stop the last running event of the given type when specified",
        "fullTitle": "events POST /stop must stop the last running event of the given type when specified",
        "duration": 55,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept an `id` param to specify the event to stop",
        "fullTitle": "events POST /stop must accept an `id` param to specify the event to stop",
        "duration": 57,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the specified event does not exist",
        "fullTitle": "events POST /stop must return an error if the specified event does not exist",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the specified event is not running",
        "fullTitle": "events POST /stop must return an error if the specified event is not running",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if no event is specified and the stream allows overlapping",
        "fullTitle": "events POST /stop must return an error if no event is specified and the stream allows overlapping",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if neither stream nor event is specified",
        "fullTitle": "events POST /stop must return an error if neither stream nor event is specified",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the attachment (reference in event + file)",
        "fullTitle": "events DELETE /<event id>/<file id> must delete the attachment (reference in event + file)",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if not existing",
        "fullTitle": "events DELETE /<event id>/<file id> must return an error if not existing",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must flag the event as trashed",
        "fullTitle": "events DELETE /<id> must flag the event as trashed",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the event when already trashed including all its attachments",
        "fullTitle": "events DELETE /<id> must delete the event when already trashed including all its attachments",
        "duration": 77,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all followed slices (ordered by user name, then access token)",
        "fullTitle": "followed slices GET / must return all followed slices (ordered by user name, then access token)",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "followed slices GET / must be forbidden to non-personal accesses",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new followed slice with the sent data, returning it",
        "fullTitle": "followed slices POST / must create a new followed slice with the sent data, returning it",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "followed slices POST / must return a correct error if the sent data is badly formatted",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the same followed slice (url and token) already exists",
        "fullTitle": "followed slices POST / must return a correct error if the same followed slice (url and token) already exists",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if a followed slice with the same name already exists",
        "fullTitle": "followed slices POST / must return a correct error if a followed slice with the same name already exists",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the followed slice with the sent data",
        "fullTitle": "followed slices PUT /<id> must modify the followed slice with the sent data",
        "duration": 31,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the followed slice does not exist",
        "fullTitle": "followed slices PUT /<id> must return a correct error if the followed slice does not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "followed slices PUT /<id> must return a correct error if the sent data is badly formatted",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if a followed slice with the same name already exists",
        "fullTitle": "followed slices PUT /<id> must return a correct error if a followed slice with the same name already exists",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the followed slice",
        "fullTitle": "followed slices DELETE /<id> must delete the followed slice",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the followed slice does not exist",
        "fullTitle": "followed slices DELETE /<id> must return a correct error if the followed slice does not exist",
        "duration": 13,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with streams schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with streams schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with streams schema must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with events schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with events schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with events schema must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with accesses schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is null",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with accesses schema must throw a forbidden error if \"ignoreProtectedFieldUpdates\" is false",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "fullTitle": "methods/helpers/commonFunctions.js: catchForbiddenUpdate(schema) with accesses schema must not throw any error if \"ignoreProtectedFieldUpdates\" is true but print a warn log",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should throw an error if mailing method is invalid",
        "fullTitle": "Mailing helper methods should throw an error if mailing method is invalid",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should throw an error if mailing method is missing",
        "fullTitle": "Mailing helper methods should throw an error if mailing method is missing",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should not be empty",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should not be empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid auth key",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain a valid auth key",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid recipient",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain a valid recipient",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid substitution of variables",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain a valid substitution of variables",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain valid tags",
        "fullTitle": "Mailing helper methods using Mandrill validating request body should contain valid tags",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should not be empty",
        "fullTitle": "Mailing helper methods using Microservice validating request body should not be empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid auth key",
        "fullTitle": "Mailing helper methods using Microservice validating request body should contain a valid auth key",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid recipient",
        "fullTitle": "Mailing helper methods using Microservice validating request body should contain a valid recipient",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should contain a valid substitution of variables",
        "fullTitle": "Mailing helper methods using Microservice validating request body should contain a valid substitution of variables",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an array preceded by a comma when called with parameter isFirst=false",
        "fullTitle": "ArrayStream must return an array preceded by a comma when called with parameter isFirst=false",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit-3 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit-3 items",
        "duration": 28,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit-2 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit-2 items",
        "duration": 17,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit-1 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit-1 items",
        "duration": 19,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+0 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+0 items",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+1 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+1 items",
        "duration": 15,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+2 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+2 items",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving limit+3 items",
        "fullTitle": "ArrayStream testing around the array size limit must return a valid array when receiving limit+3 items",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 0 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 0 item(s)",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 1 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 1 item(s)",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 2 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 2 item(s)",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a valid array when receiving 3 item(s)",
        "fullTitle": "ArrayStream testing with small number of items must return a valid array when receiving 3 item(s)",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be fed objects and return them in the callback",
        "fullTitle": "DrainStream must be fed objects and return them in the callback",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error when the provided limit is exceeded",
        "fullTitle": "DrainStream must return an error when the provided limit is exceeded",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return events in accessible streams",
        "fullTitle": "Access permissions Events `get` must only return events in accessible streams",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must return all events when permissions are defined for \"all streams\" (*)",
        "fullTitle": "Access permissions Events `get` must return all events when permissions are defined for \"all streams\" (*)",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return events with accessible tags",
        "fullTitle": "Access permissions Events `get` must only return events with accessible tags",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return events in accessible streams *and* with accessible tags when both are defined",
        "fullTitle": "Access permissions Events `get` must only return events in accessible streams *and* with accessible tags when both are defined",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` (or any request) must alternatively accept the access token in the query string",
        "fullTitle": "Access permissions Events `get` (or any request) must alternatively accept the access token in the query string",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid getting an attached file if permissions are insufficient",
        "fullTitle": "Access permissions Events must forbid getting an attached file if permissions are insufficient",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid creating events for 'read-only' streams",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid creating events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid updating events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid updating events for 'read-only' streams",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid updating events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid updating events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid stopping events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid stopping events for 'read-only' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid stopping events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid stopping events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting events for 'read-only' streams",
        "fullTitle": "Access permissions Events must forbid deleting events for 'read-only' streams",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting events for 'read-only' tags",
        "fullTitle": "Access permissions Events must forbid deleting events for 'read-only' tags",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creating events for 'contribute' streams",
        "fullTitle": "Access permissions Events must allow creating events for 'contribute' streams",
        "duration": 26,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creating events for 'contribute' tags",
        "fullTitle": "Access permissions Events must allow creating events for 'contribute' tags",
        "duration": 19,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "`get` must only return streams for which permissions are defined",
        "fullTitle": "Access permissions Streams `get` must only return streams for which permissions are defined",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating child streams in 'read-only' streams",
        "fullTitle": "Access permissions Streams must forbid creating child streams in 'read-only' streams",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid creating child streams in 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid creating child streams in 'contribute' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting child streams in 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid deleting child streams in 'contribute' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid updating 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid updating 'contribute' streams",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid deleting 'contribute' streams",
        "fullTitle": "Access permissions Streams must forbid deleting 'contribute' streams",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow creating child streams in 'managed' streams",
        "fullTitle": "Access permissions Streams must allow creating child streams in 'managed' streams",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid moving streams into non-'managed' parent streams",
        "fullTitle": "Access permissions Streams must forbid moving streams into non-'managed' parent streams",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow deleting child streams in 'managed' streams",
        "fullTitle": "Access permissions Streams must allow deleting child streams in 'managed' streams",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must recursively apply permissions to the streams' child streams",
        "fullTitle": "Access permissions Streams must recursively apply permissions to the streams' child streams",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow access to all streams when no specific stream permissions are defined",
        "fullTitle": "Access permissions Streams must allow access to all streams when no specific stream permissions are defined",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow access to all streams when only tag permissions are defined",
        "fullTitle": "Access permissions Streams must allow access to all streams when only tag permissions are defined",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must only allow access to set streams when both tag and stream permissions are defined",
        "fullTitle": "Access permissions Streams must only allow access to set streams when both tag and stream permissions are defined",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must handle optional caller id in auth (in addition to token)",
        "fullTitle": "Access permissions Auth and change tracking must handle optional caller id in auth (in addition to token)",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be supported and deny access when failing",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must be supported and deny access when failing",
        "duration": 60,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow access when successful",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must allow access when successful",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail properly (i.e. not granting access) when the custom function crashes",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must fail properly (i.e. not granting access) when the custom function crashes",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must validate the custom function at startup time",
        "fullTitle": "Access permissions Auth and change tracking custom auth step (e.g. to validate/parse caller id) must validate the custom function at startup time",
        "duration": 518,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return publicly shared key-value profile info",
        "fullTitle": "profile (app) GET /public must return publicly shared key-value profile info",
        "duration": 55,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return key-value settings for the current app",
        "fullTitle": "profile (app) GET /app must return key-value settings for the current app",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a shared access token",
        "fullTitle": "profile (app) GET /app must refuse requests with a shared access token",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a personal access token",
        "fullTitle": "profile (app) GET /app must refuse requests with a personal access token",
        "duration": 116,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add/update/remove the specified keys without touching the others",
        "fullTitle": "profile (app) PUT /app must add/update/remove the specified keys without touching the others",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a shared access token",
        "fullTitle": "profile (app) PUT /app must refuse requests with a shared access token",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse requests with a personal access token",
        "fullTitle": "profile (app) PUT /app must refuse requests with a personal access token",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/public must return publicly shared key-value profile info",
        "fullTitle": "profile (personal) GET /public must return publicly shared key-value profile info",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/private must return private key-value profile info",
        "fullTitle": "profile (personal) GET /private must return private key-value profile info",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an appropriate error for other paths",
        "fullTitle": "profile (personal) GET must return an appropriate error for other paths",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "\"private\" must be forbidden to non-personal accesses",
        "fullTitle": "profile (personal) GET \"private\" must be forbidden to non-personal accesses",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/public must add/update/remove the specified keys without touching the others",
        "fullTitle": "profile (personal) PUT /public must add/update/remove the specified keys without touching the others",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "/private must add/update/remove the specified keys without touching the others",
        "fullTitle": "profile (personal) PUT /private must add/update/remove the specified keys without touching the others",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create the profile if not existing",
        "fullTitle": "profile (personal) PUT must create the profile if not existing",
        "duration": 51,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an appropriate error for other paths",
        "fullTitle": "profile (personal) PUT must return an appropriate error for other paths",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must be forbidden to non-personal accesses",
        "fullTitle": "profile (personal) PUT must be forbidden to non-personal accesses",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the result's content when not storing streams",
        "fullTitle": "Result toObject() must return the result's content when not storing streams",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the result content when storing streams",
        "fullTitle": "Result toObject() must return the result content when storing streams",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error object when attempting to serialize streams containing an amountof objects exceeding the limit",
        "fullTitle": "Result toObject() must return an error object when attempting to serialize streams containing an amountof objects exceeding the limit",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error when storing piped streams",
        "fullTitle": "Result toObject() must return an error when storing piped streams",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return basic server meta information as JSON when requested",
        "fullTitle": "root GET / should return basic server meta information as JSON when requested",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return basic server meta information as text otherwise",
        "fullTitle": "root GET / should return basic server meta information as text otherwise",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an error if trying to access an unknown user account",
        "fullTitle": "root GET / should return an error if trying to access an unknown user account",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return correct common HTTP headers + meta data in response body",
        "fullTitle": "root All requests: should return correct common HTTP headers + meta data in response body",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return meta data in response body for errors as well",
        "fullTitle": "root All requests: should return meta data in response body for errors as well",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should properly translate the Host header's username (i.e. subdomain)",
        "fullTitle": "root All requests: should properly translate the Host header's username (i.e. subdomain)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should translate the username in subdomain also when it only contains numbers",
        "fullTitle": "root All requests: should translate the username in subdomain also when it only contains numbers",
        "duration": 118,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should support POSTing \"urlencoded\" content with _json and _auth fields",
        "fullTitle": "root All requests: should support POSTing \"urlencoded\" content with _json and _auth fields",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should support POSTing \"urlencoded\" content with _json, _method (PUT) and _auth fields",
        "fullTitle": "root All requests: should support POSTing \"urlencoded\" content with _json, _method (PUT) and _auth fields",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should support POSTing \"urlencoded\" content with _json, _method (DELETE) and _auth fields",
        "fullTitle": "root All requests: should support POSTing \"urlencoded\" content with _json, _method (DELETE) and _auth fields",
        "duration": 52,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should properly handle JSON errors when POSTing \"urlencoded\" content with _json field",
        "fullTitle": "root All requests: should properly handle JSON errors when POSTing \"urlencoded\" content with _json field",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should update the access's \"last used\" time and *internal* request counters",
        "fullTitle": "root All requests: should update the access's \"last used\" time and *internal* request counters",
        "duration": 20,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return OK",
        "fullTitle": "root OPTIONS / should return OK",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return current access information",
        "fullTitle": "root GET /access-info must return current access information",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must execute the given method calls and return the results",
        "fullTitle": "root POST / (i.e. batch call) must execute the given method calls and return the results",
        "duration": 76,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must execute the method calls containing events.get and return the results",
        "fullTitle": "root POST / (i.e. batch call) must execute the method calls containing events.get and return the results",
        "duration": 74,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the sent data is badly formatted",
        "fullTitle": "root POST / (i.e. batch call) must return an error if the sent data is badly formatted",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must dynamically create a namespace for the user",
        "fullTitle": "Socket.IO must dynamically create a namespace for the user",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must connect to a user with a dash in the username",
        "fullTitle": "Socket.IO must connect to a user with a dash in the username",
        "duration": 142,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must refuse connection if no valid access token is provided",
        "fullTitle": "Socket.IO must refuse connection if no valid access token is provided",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly route method call messages for events and return the results, including meta",
        "fullTitle": "Socket.IO calling API methods must properly route method call messages for events and return the results, including meta",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must properly route method call messages for streams and return the results",
        "fullTitle": "Socket.IO calling API methods must properly route method call messages for streams and return the results",
        "duration": 16,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not crash when callers omit the callback",
        "fullTitle": "Socket.IO calling API methods must not crash when callers omit the callback",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if the called target does not exist",
        "fullTitle": "Socket.IO calling API methods must fail if the called target does not exist",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if the called method does not exist",
        "fullTitle": "Socket.IO calling API methods must fail if the called method does not exist",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return API errors properly, including meta",
        "fullTitle": "Socket.IO calling API methods must return API errors properly, including meta",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must notify other sockets for the same user about events changes",
        "fullTitle": "Socket.IO calling API methods must notify other sockets for the same user about events changes",
        "duration": 36,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must notify other sockets for the same user (only) about streams changes",
        "fullTitle": "Socket.IO calling API methods must notify other sockets for the same user (only) about streams changes",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must notify on each change",
        "fullTitle": "Socket.IO calling API methods must notify on each change",
        "duration": 64,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "changes made in A notify clients of B",
        "fullTitle": "Socket.IO when spawning 2 api-server processes, A and B changes made in A notify clients of B",
        "duration": 119,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return non-trashed streams (as a tree) by default",
        "fullTitle": "streams GET / must return non-trashed streams (as a tree) by default",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return all streams (trashed or not) when requested",
        "fullTitle": "streams GET / must return all streams (trashed or not) when requested",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must include stream deletions (since the given time) when requested",
        "fullTitle": "streams GET / must include stream deletions (since the given time) when requested",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must include stream deletions even when the given time is 0",
        "fullTitle": "streams GET / must include stream deletions even when the given time is 0",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 401 error if no access token is provided",
        "fullTitle": "streams GET / must return a correct 401 error if no access token is provided",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return child streams when providing a parent stream id",
        "fullTitle": "streams GET / must return child streams when providing a parent stream id",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the parent stream is unknown",
        "fullTitle": "streams GET / must return a correct error if the parent stream is unknown",
        "duration": 19,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new \"root\" stream with the sent data, returning it",
        "fullTitle": "streams POST / must create a new \"root\" stream with the sent data, returning it",
        "duration": 39,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "streams POST / must return a correct error if the sent data is badly formatted",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if a stream with the same id already exists",
        "fullTitle": "streams POST / must return a correct error if a stream with the same id already exists",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must allow reuse of deleted ids",
        "fullTitle": "streams POST / must allow reuse of deleted ids",
        "duration": 45,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "streams POST / must accept explicit null for optional fields",
        "duration": 28,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if a sibling stream with the same name already exists",
        "fullTitle": "streams POST / must fail if a sibling stream with the same name already exists",
        "duration": 21,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is not valid JSON",
        "fullTitle": "streams POST / must return a correct error if the sent data is not valid JSON",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new child stream (with predefined id) when providing a parent stream id",
        "fullTitle": "streams POST / must create a new child stream (with predefined id) when providing a parent stream id",
        "duration": 31,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an error if the new stream's parentId is the empty string",
        "fullTitle": "streams POST / must return an error if the new stream's parentId is the empty string",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must slugify the new stream's predefined id",
        "fullTitle": "streams POST / must slugify the new stream's predefined id",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the parent stream is unknown",
        "fullTitle": "streams POST / must return a correct error if the parent stream is unknown",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the given predefined stream's id is \"null\"",
        "fullTitle": "streams POST / must return a correct error if the given predefined stream's id is \"null\"",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the given predefined stream's id is \"*\"",
        "fullTitle": "streams POST / must return a correct error if the given predefined stream's id is \"*\"",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must modify the stream with the sent data",
        "fullTitle": "streams PUT /<id> must modify the stream with the sent data",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept explicit null for optional fields",
        "fullTitle": "streams PUT /<id> must accept explicit null for optional fields",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must add/update/remove the specified client data fields without touching the others",
        "fullTitle": "streams PUT /<id> must add/update/remove the specified client data fields without touching the others",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the stream does not exist",
        "fullTitle": "streams PUT /<id> must return a correct error if the stream does not exist",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the sent data is badly formatted",
        "fullTitle": "streams PUT /<id> must return a correct error if the sent data is badly formatted",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail if a sibling stream with the same name already exists",
        "fullTitle": "streams PUT /<id> must fail if a sibling stream with the same name already exists",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must move the stream under the given parent when specified",
        "fullTitle": "streams PUT /<id> must move the stream under the given parent when specified",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the new parent stream is unknown",
        "fullTitle": "streams PUT /<id> must return a correct error if the new parent stream is unknown",
        "duration": 11,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must fail and throw a forbidden error in strict mode",
        "fullTitle": "streams PUT /<id> forbidden updates of protected fields must fail and throw a forbidden error in strict mode",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must succeed by ignoring protected fields and log a warning in non-strict mode",
        "fullTitle": "streams PUT /<id> forbidden updates of protected fields must succeed by ignoring protected fields and log a warning in non-strict mode",
        "duration": 1287,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must flag the specified stream as trashed",
        "fullTitle": "streams DELETE /<id> must flag the specified stream as trashed",
        "duration": 35,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the stream when already trashed with its descendants if there are no linked events",
        "fullTitle": "streams DELETE /<id> must delete the stream when already trashed with its descendants if there are no linked events",
        "duration": 56,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if there are linked events and the related parameter is missing",
        "fullTitle": "streams DELETE /<id> must return a correct error if there are linked events and the related parameter is missing",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reject the deletion of a root stream with mergeEventsWithParent=true",
        "fullTitle": "streams DELETE /<id> must reject the deletion of a root stream with mergeEventsWithParent=true",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must reassign the linked events to the deleted stream's parent when specified",
        "fullTitle": "streams DELETE /<id> must reassign the linked events to the deleted stream's parent when specified",
        "duration": 56,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must delete the linked events when mergeEventsWithParent is false",
        "fullTitle": "streams DELETE /<id> must delete the linked events when mergeEventsWithParent is false",
        "duration": 133,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the item is unknown",
        "fullTitle": "streams DELETE /<id> must return a correct error if the item is unknown",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not send a welcome email if mailing is deactivated",
        "fullTitle": "system (ex-register) POST /create-user must not send a welcome email if mailing is deactivated",
        "duration": 1345,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not send a welcome email if welcome mail is deactivated",
        "fullTitle": "system (ex-register) POST /create-user must not send a welcome email if welcome mail is deactivated",
        "duration": 1350,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must create a new user with the sent data, sending a welcome email",
        "fullTitle": "system (ex-register) POST /create-user when email sending really works must create a new user with the sent data, sending a welcome email",
        "duration": 1348,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must run the process but not save anything for test username \"recla\"",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must run the process but not save anything for test username \"recla\"",
        "duration": 1239,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must support the old \"/register\" path for backwards-compatibility",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must support the old \"/register\" path for backwards-compatibility",
        "duration": 65,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if the sent data is badly formatted",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if the sent data is badly formatted",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if the language property is above 5 characters",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if the language property is above 5 characters",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if the language property is the empty string",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if the language property is the empty string",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if a user with the same user name already exists",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if a user with the same user name already exists",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 400 error if a user with the same email address already exists",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 400 error if a user with the same email address already exists",
        "duration": 6,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 404 error when authentication is invalid",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct 404 error when authentication is invalid",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct error if the content type is wrong",
        "fullTitle": "system (ex-register) POST /create-user when it just replies OK must return a correct error if the content type is wrong",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must replace the passwordHash in the logs by (hidden) when the authentication is invalid",
        "fullTitle": "system (ex-register) POST /create-user when we log into a temporary log file must replace the passwordHash in the logs by (hidden) when the authentication is invalid",
        "duration": 27,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must replace the passwordHash in the logs by (hidden) when the payload is invalid (here parameters)",
        "fullTitle": "system (ex-register) POST /create-user when we log into a temporary log file must replace the passwordHash in the logs by (hidden) when the payload is invalid (here parameters)",
        "duration": 9,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must not mention the passwordHash in the logs when none is provided",
        "fullTitle": "system (ex-register) POST /create-user when we log into a temporary log file must not mention the passwordHash in the logs when none is provided",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return user information (including time of last account use)",
        "fullTitle": "system (ex-register) GET /user-info/{username} must return user information (including time of last account use)",
        "duration": 84,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a correct 404 error when authentication is invalid",
        "fullTitle": "system (ex-register) GET /user-info/{username} must return a correct 404 error when authentication is invalid",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should parse file uploads",
        "fullTitle": "uploads middleware hasFileUpload should parse file uploads",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #serverReady notifies internal listeners",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #serverReady notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #accountChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #accountChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #accessesChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #accessesChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #followedSlicesChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #followedSlicesChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #streamsChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #streamsChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies internal listeners",
        "fullTitle": "Notifications #eventsChanged notifies internal listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "notifies axon listeners",
        "fullTitle": "Notifications #eventsChanged notifies axon listeners",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns true if all properties exist",
        "fullTitle": "Authentication hasProperties returns true if all properties exist",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns false if not all properties exist",
        "fullTitle": "Authentication hasProperties returns false if not all properties exist",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns false if null is given",
        "fullTitle": "Authentication hasProperties returns false if null is given",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns false if a string is given",
        "fullTitle": "Authentication hasProperties returns false if a string is given",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should behave as documented in the method",
        "fullTitle": "tryCoerceStringValues should behave as documented in the method",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "doesn't create keys in object",
        "fullTitle": "tryCoerceStringValues doesn't create keys in object",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should convert to array",
        "fullTitle": "tryCoerceStringValues should convert to array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "number conversion works",
        "fullTitle": "tryCoerceStringValues number conversion works",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should construct",
        "fullTitle": "NatsPublisher should construct",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "delivers messages to \"USERNAME.sok1\"",
        "fullTitle": "NatsPublisher delivers messages to \"USERNAME.sok1\"",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should construct",
        "fullTitle": "NatsSubscriber should construct",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "accepts messages from USERNAME.sok1 and dispatches them to sinks",
        "fullTitle": "NatsSubscriber when subscribed to \"foobar\" subscribe(\"USERNAME\") accepts messages from USERNAME.sok1 and dispatches them to sinks",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "ignores messages from other users",
        "fullTitle": "NatsSubscriber when subscribed to \"foobar\" subscribe(\"USERNAME\") ignores messages from other users",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should unsubscribe from NATS",
        "fullTitle": "NatsSubscriber when subscribed to \"foobar\" unsubscribe() should unsubscribe from NATS",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "api-server"
  },
  {
    "stats": {
      "suites": 22,
      "tests": 43,
      "passes": 39,
      "pending": 0,
      "failures": 4,
      "start": "2019-05-06T11:53:21.275Z",
      "end": "2019-05-06T11:53:21.467Z",
      "duration": 192
    },
    "tests": [
      {
        "title": "should allow writing to a series",
        "fullTitle": "Manage InfluxDB data (business.series.*) should allow writing to a series",
        "duration": 46,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should parse the happy case",
        "fullTitle": "BatchRequest .parse should parse the happy case",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "accepts an empty batch",
        "fullTitle": "BatchRequest .parse accepts an empty batch",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws if format is missing or wrong",
        "fullTitle": "BatchRequest .parse throws if format is missing or wrong",
        "duration": 1,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:64:14)\n    at Context.it (test/unit/series/batch_request.test.js:48:7)"
        }
      },
      {
        "title": "throws if another type is passed in",
        "fullTitle": "BatchRequest .parse throws if another type is passed in",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws if envelope doesn't have a data attribute",
        "fullTitle": "BatchRequest .parse throws if envelope doesn't have a data attribute",
        "duration": 0,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:64:14)\n    at Context.it (test/unit/series/batch_request.test.js:57:7)"
        }
      },
      {
        "title": "should parse a good looking object",
        "fullTitle": "BatchRequestElement .parse(obj) should parse a good looking object",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails if input is not an Object",
        "fullTitle": "BatchRequestElement .parse(obj) fails if input is not an Object",
        "duration": 0,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:103:14)\n    at Context.it (test/unit/series/batch_request.test.js:94:7)"
        }
      },
      {
        "title": "fails if eventId is missing or the wrong type",
        "fullTitle": "BatchRequestElement .parse(obj) fails if eventId is missing or the wrong type",
        "duration": 1,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:103:14)\n    at Context.it (test/unit/series/batch_request.test.js:98:7)"
        }
      },
      {
        "title": "should accept the happy path",
        "fullTitle": "DataMatrix .parse(obj) should accept the happy path",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if not an object",
        "fullTitle": "DataMatrix .parse(obj) refuses if not an object",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if format is not flatJSON",
        "fullTitle": "DataMatrix .parse(obj) refuses if format is not flatJSON",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if fields are not strings",
        "fullTitle": "DataMatrix .parse(obj) refuses if fields are not strings",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if points is not an array",
        "fullTitle": "DataMatrix .parse(obj) refuses if points is not an array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if field names are not correct",
        "fullTitle": "DataMatrix .parse(obj) refuses if field names are not correct",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if data cannot be coerced",
        "fullTitle": "DataMatrix .parse(obj) refuses if data cannot be coerced",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should iterate over all matrix rows",
        "fullTitle": "DataMatrix #eachRow should iterate over all matrix rows",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should call fn for each cell",
        "fullTitle": "DataMatrix #transform should call fn for each cell",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should store the return value in the matrix",
        "fullTitle": "DataMatrix #transform should store the return value in the matrix",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the minimum and maximum timestamp used",
        "fullTitle": "DataMatrix #minmax() returns the minimum and maximum timestamp used",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws an error if the matrix is empty",
        "fullTitle": "DataMatrix #minmax() throws an error if the matrix is empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws an error if the timestamp is missing",
        "fullTitle": "DataMatrix #minmax() throws an error if the timestamp is missing",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a js object for the row",
        "fullTitle": "business.series.Row toStruct should return a js object for the row",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should produce series objects for events",
        "fullTitle": "business.series.Repository with stubbed out connection should produce series objects for events",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should work (must be called manually)",
        "fullTitle": "business.types.TypeRepository type list update should work (must be called manually)",
        "duration": 96,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should fail gracefully",
        "fullTitle": "business.types.TypeRepository type list update should fail gracefully",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a type instance allowing conversion",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should return a type instance allowing conversion",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should throw when conversion fails",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should throw when conversion fails",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should coerce to number during validation",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should coerce to number during validation",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository complex types like position/wgs84 should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a complex type instance",
        "fullTitle": "business.types.TypeRepository complex types like position/wgs84 should return a complex type instance",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return the correct value type for all fields",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook should return the correct value type for all fields",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return the correct value type for optional fields",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook should return the correct value type for optional fields",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should resolve nested fields",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook should resolve nested fields",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "does NOT handle requiredFields fully yet: only surface requirements are returned",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook does NOT handle requiredFields fully yet: only surface requirements are returned",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository placeholder types like picture/attached should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a type instance allowing conversion",
        "fullTitle": "business.types.TypeRepository placeholder types like picture/attached should return a type instance allowing conversion",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository series types like series:mass/kg should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should inform about fields correctly",
        "fullTitle": "business.types.TypeRepository series types like series:mass/kg should inform about fields correctly",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be produced via a type repository",
        "fullTitle": "business.types.TypeValidator should be produced via a type repository",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should validate simple types",
        "fullTitle": "business.types.TypeValidator should validate simple types",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should validate complex types",
        "fullTitle": "business.types.TypeValidator should validate complex types",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [
      {
        "title": "throws if format is missing or wrong",
        "fullTitle": "BatchRequest .parse throws if format is missing or wrong",
        "duration": 1,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:64:14)\n    at Context.it (test/unit/series/batch_request.test.js:48:7)"
        }
      },
      {
        "title": "throws if envelope doesn't have a data attribute",
        "fullTitle": "BatchRequest .parse throws if envelope doesn't have a data attribute",
        "duration": 0,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:64:14)\n    at Context.it (test/unit/series/batch_request.test.js:57:7)"
        }
      },
      {
        "title": "fails if input is not an Object",
        "fullTitle": "BatchRequestElement .parse(obj) fails if input is not an Object",
        "duration": 0,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:103:14)\n    at Context.it (test/unit/series/batch_request.test.js:94:7)"
        }
      },
      {
        "title": "fails if eventId is missing or the wrong type",
        "fullTitle": "BatchRequestElement .parse(obj) fails if eventId is missing or the wrong type",
        "duration": 1,
        "currentRetry": 0,
        "err": {
          "message": "expected [Function] to throw ParseFailure",
          "showDiff": true,
          "expected": "class ParseFailure extends Error {}",
          "stack": "AssertionError: expected [Function] to throw ParseFailure\n    at bad (test/unit/series/batch_request.test.js:103:14)\n    at Context.it (test/unit/series/batch_request.test.js:98:7)"
        }
      }
    ],
    "passes": [
      {
        "title": "should allow writing to a series",
        "fullTitle": "Manage InfluxDB data (business.series.*) should allow writing to a series",
        "duration": 46,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should parse the happy case",
        "fullTitle": "BatchRequest .parse should parse the happy case",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "accepts an empty batch",
        "fullTitle": "BatchRequest .parse accepts an empty batch",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws if another type is passed in",
        "fullTitle": "BatchRequest .parse throws if another type is passed in",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should parse a good looking object",
        "fullTitle": "BatchRequestElement .parse(obj) should parse a good looking object",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should accept the happy path",
        "fullTitle": "DataMatrix .parse(obj) should accept the happy path",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if not an object",
        "fullTitle": "DataMatrix .parse(obj) refuses if not an object",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if format is not flatJSON",
        "fullTitle": "DataMatrix .parse(obj) refuses if format is not flatJSON",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if fields are not strings",
        "fullTitle": "DataMatrix .parse(obj) refuses if fields are not strings",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if points is not an array",
        "fullTitle": "DataMatrix .parse(obj) refuses if points is not an array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if field names are not correct",
        "fullTitle": "DataMatrix .parse(obj) refuses if field names are not correct",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses if data cannot be coerced",
        "fullTitle": "DataMatrix .parse(obj) refuses if data cannot be coerced",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should iterate over all matrix rows",
        "fullTitle": "DataMatrix #eachRow should iterate over all matrix rows",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should call fn for each cell",
        "fullTitle": "DataMatrix #transform should call fn for each cell",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should store the return value in the matrix",
        "fullTitle": "DataMatrix #transform should store the return value in the matrix",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the minimum and maximum timestamp used",
        "fullTitle": "DataMatrix #minmax() returns the minimum and maximum timestamp used",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws an error if the matrix is empty",
        "fullTitle": "DataMatrix #minmax() throws an error if the matrix is empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws an error if the timestamp is missing",
        "fullTitle": "DataMatrix #minmax() throws an error if the timestamp is missing",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a js object for the row",
        "fullTitle": "business.series.Row toStruct should return a js object for the row",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should produce series objects for events",
        "fullTitle": "business.series.Repository with stubbed out connection should produce series objects for events",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should work (must be called manually)",
        "fullTitle": "business.types.TypeRepository type list update should work (must be called manually)",
        "duration": 96,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should fail gracefully",
        "fullTitle": "business.types.TypeRepository type list update should fail gracefully",
        "duration": 7,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a type instance allowing conversion",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should return a type instance allowing conversion",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should throw when conversion fails",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should throw when conversion fails",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should coerce to number during validation",
        "fullTitle": "business.types.TypeRepository basic types like mass/kg should coerce to number during validation",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository complex types like position/wgs84 should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a complex type instance",
        "fullTitle": "business.types.TypeRepository complex types like position/wgs84 should return a complex type instance",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return the correct value type for all fields",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook should return the correct value type for all fields",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return the correct value type for optional fields",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook should return the correct value type for optional fields",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should resolve nested fields",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook should resolve nested fields",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "does NOT handle requiredFields fully yet: only surface requirements are returned",
        "fullTitle": "business.types.TypeRepository complex types on several levels like message/facebook does NOT handle requiredFields fully yet: only surface requirements are returned",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository placeholder types like picture/attached should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return a type instance allowing conversion",
        "fullTitle": "business.types.TypeRepository placeholder types like picture/attached should return a type instance allowing conversion",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be known",
        "fullTitle": "business.types.TypeRepository series types like series:mass/kg should be known",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should inform about fields correctly",
        "fullTitle": "business.types.TypeRepository series types like series:mass/kg should inform about fields correctly",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be produced via a type repository",
        "fullTitle": "business.types.TypeValidator should be produced via a type repository",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should validate simple types",
        "fullTitle": "business.types.TypeValidator should validate simple types",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should validate complex types",
        "fullTitle": "business.types.TypeValidator should validate complex types",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "business"
  },
  {
    "stats": {
      "suites": 26,
      "tests": 43,
      "passes": 43,
      "pending": 0,
      "failures": 0,
      "start": "2019-05-06T11:53:22.780Z",
      "end": "2019-05-06T11:53:29.777Z",
      "duration": 6997
    },
    "tests": [
      {
        "title": "should store data correctly",
        "fullTitle": "Storing BATCH data in a HF series Use Case: Store data in InfluxDB, Verification on either half should store data correctly",
        "duration": 114,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should fail without 'Authorization' header",
        "fullTitle": "Storing BATCH data in a HF series POST /:user_name/series/batch should fail without 'Authorization' header",
        "duration": 26,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "Storing BATCH data in a HF series POST /:user_name/series/batch when the token has no permissions on the event fails",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should schedule a metadata update on every store",
        "fullTitle": "Storing BATCH data in a HF series POST /:user_name/series/batch when using a metadata updater stub should schedule a metadata update on every store",
        "duration": 138,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query for an unknown user",
        "fullTitle": "Querying data from a HF series should refuse a query for an unknown user",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query missing the authorization token",
        "fullTitle": "Querying data from a HF series should refuse a query missing the authorization token",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query containing an unauthorized token",
        "fullTitle": "Querying data from a HF series should refuse a query containing an unauthorized token",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an unknown resource error when querying data for an nonexistent event id",
        "fullTitle": "Querying data from a HF series should return an unknown resource error when querying data for an nonexistent event id",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query containing parameters with the wrong format",
        "fullTitle": "Querying data from a HF series should refuse a query containing parameters with the wrong format",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query when toTime is before fromTime",
        "fullTitle": "Querying data from a HF series should refuse a query when toTime is before fromTime",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should store data correctly",
        "fullTitle": "Storing data in a HF series Use Case: Store data in InfluxDB, Verification on either half should store data correctly",
        "duration": 103,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return data once stored",
        "fullTitle": "Storing data in a HF series Use Case: Store data in InfluxDB, Verification on either half should return data once stored",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores data into InfluxDB",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success stores data into InfluxDB",
        "duration": 52,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should reject non-JSON bodies",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success should reject non-JSON bodies",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "responds with headers that allow CORS on OPTIONS",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success responds with headers that allow CORS on OPTIONS",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "responds with headers that allow CORS on POST",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success responds with headers that allow CORS on POST",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (format is not flatJSON)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (format is not flatJSON)",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (matrix is not square - not enough fields)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (matrix is not square - not enough fields)",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (value types are not all valid)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (value types are not all valid)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (missing timestamp column)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (missing timestamp column)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (missing value column for a simple input)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (missing value column for a simple input)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should schedule a metadata update on every store",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when using a metadata updater stub should schedule a metadata update on every store",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses invalid/unauthorized accesses",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth failure refuses invalid/unauthorized accesses",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores data of any basic type",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores data of any basic type",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores data of complex types",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores data of complex types",
        "duration": 28,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "doesn't accept data in non-series format",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats doesn't accept data in non-series format",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores strings",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores strings",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores floats",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores floats",
        "duration": 52,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when timestamp is present twice (ambiguous!)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic refuses to store when timestamp is present twice (ambiguous!)",
        "duration": 85,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when other fields are present twice (ambiguous!)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic refuses to store when other fields are present twice (ambiguous!)",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when not all required fields are given",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when not all required fields are given refuses to store when not all required fields are given",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns error id \"invalid-request-structure\"",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when not all required fields are given returns error id \"invalid-request-structure\"",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when field names don't match the type",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when field names don't match the type refuses to store when field names don't match the type",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the error message with the id \"invalid-request-structure\"",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when field names don't match the type returns the error message with the id \"invalid-request-structure\"",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "allows storing any number of optional fields, on each request",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as position/wgs84 allows storing any number of optional fields, on each request",
        "duration": 105,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses unknown fields",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as position/wgs84 refuses unknown fields",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should allow write access to series",
        "fullTitle": "Metadata Loader should allow write access to series",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns loaded metadata for N minutes",
        "fullTitle": "Metadata Cache returns loaded metadata for N minutes",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "can be constructed",
        "fullTitle": "Server can be constructed",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "starts a http server on configured port",
        "fullTitle": "Server .start starts a http server on configured port",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should have been loaded for test execution",
        "fullTitle": "Settings should have been loaded for test execution",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should reject queries if the authorization header is missing",
        "fullTitle": "Controller storeSeriesData should reject queries if the authorization header is missing",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should reject queries if the eventId is missing",
        "fullTitle": "Controller storeSeriesData should reject queries if the eventId is missing",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [],
    "passes": [
      {
        "title": "should store data correctly",
        "fullTitle": "Storing BATCH data in a HF series Use Case: Store data in InfluxDB, Verification on either half should store data correctly",
        "duration": 114,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should fail without 'Authorization' header",
        "fullTitle": "Storing BATCH data in a HF series POST /:user_name/series/batch should fail without 'Authorization' header",
        "duration": 26,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails",
        "fullTitle": "Storing BATCH data in a HF series POST /:user_name/series/batch when the token has no permissions on the event fails",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should schedule a metadata update on every store",
        "fullTitle": "Storing BATCH data in a HF series POST /:user_name/series/batch when using a metadata updater stub should schedule a metadata update on every store",
        "duration": 138,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query for an unknown user",
        "fullTitle": "Querying data from a HF series should refuse a query for an unknown user",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query missing the authorization token",
        "fullTitle": "Querying data from a HF series should refuse a query missing the authorization token",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query containing an unauthorized token",
        "fullTitle": "Querying data from a HF series should refuse a query containing an unauthorized token",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return an unknown resource error when querying data for an nonexistent event id",
        "fullTitle": "Querying data from a HF series should return an unknown resource error when querying data for an nonexistent event id",
        "duration": 32,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query containing parameters with the wrong format",
        "fullTitle": "Querying data from a HF series should refuse a query containing parameters with the wrong format",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should refuse a query when toTime is before fromTime",
        "fullTitle": "Querying data from a HF series should refuse a query when toTime is before fromTime",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should store data correctly",
        "fullTitle": "Storing data in a HF series Use Case: Store data in InfluxDB, Verification on either half should store data correctly",
        "duration": 103,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return data once stored",
        "fullTitle": "Storing data in a HF series Use Case: Store data in InfluxDB, Verification on either half should return data once stored",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores data into InfluxDB",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success stores data into InfluxDB",
        "duration": 52,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should reject non-JSON bodies",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success should reject non-JSON bodies",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "responds with headers that allow CORS on OPTIONS",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success responds with headers that allow CORS on OPTIONS",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "responds with headers that allow CORS on POST",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success responds with headers that allow CORS on POST",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (format is not flatJSON)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (format is not flatJSON)",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (matrix is not square - not enough fields)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (matrix is not square - not enough fields)",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (value types are not all valid)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (value types are not all valid)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (missing timestamp column)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (missing timestamp column)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should be rejected (missing value column for a simple input)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when request is malformed should be rejected (missing value column for a simple input)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should schedule a metadata update on every store",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth success when using a metadata updater stub should schedule a metadata update on every store",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses invalid/unauthorized accesses",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series bypassing authentication with auth failure refuses invalid/unauthorized accesses",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores data of any basic type",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores data of any basic type",
        "duration": 106,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores data of complex types",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores data of complex types",
        "duration": 28,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "doesn't accept data in non-series format",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats doesn't accept data in non-series format",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores strings",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores strings",
        "duration": 34,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores floats",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series storing data in different formats stores floats",
        "duration": 52,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when timestamp is present twice (ambiguous!)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic refuses to store when timestamp is present twice (ambiguous!)",
        "duration": 85,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when other fields are present twice (ambiguous!)",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic refuses to store when other fields are present twice (ambiguous!)",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when not all required fields are given",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when not all required fields are given refuses to store when not all required fields are given",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns error id \"invalid-request-structure\"",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when not all required fields are given returns error id \"invalid-request-structure\"",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses to store when field names don't match the type",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when field names don't match the type refuses to store when field names don't match the type",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the error message with the id \"invalid-request-structure\"",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as ratio/generic when field names don't match the type returns the error message with the id \"invalid-request-structure\"",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "allows storing any number of optional fields, on each request",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as position/wgs84 allows storing any number of optional fields, on each request",
        "duration": 105,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "refuses unknown fields",
        "fullTitle": "Storing data in a HF series POST /events/EVENT_ID/series complex types such as position/wgs84 refuses unknown fields",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should allow write access to series",
        "fullTitle": "Metadata Loader should allow write access to series",
        "duration": 24,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns loaded metadata for N minutes",
        "fullTitle": "Metadata Cache returns loaded metadata for N minutes",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "can be constructed",
        "fullTitle": "Server can be constructed",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "starts a http server on configured port",
        "fullTitle": "Server .start starts a http server on configured port",
        "duration": 12,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should have been loaded for test execution",
        "fullTitle": "Settings should have been loaded for test execution",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should reject queries if the authorization header is missing",
        "fullTitle": "Controller storeSeriesData should reject queries if the authorization header is missing",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should reject queries if the eventId is missing",
        "fullTitle": "Controller storeSeriesData should reject queries if the eventId is missing",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "hfs-server"
  },
  {
    "stats": {
      "suites": 22,
      "tests": 26,
      "passes": 26,
      "pending": 0,
      "failures": 0,
      "start": "2019-05-06T11:53:31.362Z",
      "end": "2019-05-06T11:53:32.383Z",
      "duration": 1021
    },
    "tests": [
      {
        "title": "allows scheduling an update",
        "fullTitle": "Metadata Updater allows scheduling an update",
        "duration": 45,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "starts a timer and runs #act every n ms",
        "fullTitle": "Metadata Updater/Controller #runEach(ms) starts a timer and runs #act every n ms",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "constructs an Flush operation for the update and returns it",
        "fullTitle": "Metadata Updater/Controller #flushOp(update) constructs an Flush operation for the update and returns it",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "pulls elapsed updates and flushes them to MongoDB",
        "fullTitle": "Metadata Updater/Controller #act pulls elapsed updates and flushes them to MongoDB",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "forwards calls",
        "fullTitle": "ErrorLogger forwards calls",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "catches and logs all exceptions, rethrowing afterwards",
        "fullTitle": "ErrorLogger catches and logs all exceptions, rethrowing afterwards",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "also works for async methods, waiting for the eventual result",
        "fullTitle": "ErrorLogger also works for async methods, waiting for the eventual result",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "writes event metadata to disk",
        "fullTitle": "Flush event with no existing metadata writes event metadata to disk",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "doesn't destroy old earliest and latest",
        "fullTitle": "Flush event with existing metadata doesn't destroy old earliest and latest",
        "duration": 13,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "leaves base data intact",
        "fullTitle": "Flush event with existing metadata leaves base data intact",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the user id",
        "fullTitle": "UserRepository #resolve(name) returns the user id",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "caches the user information for a while",
        "fullTitle": "UserRepository #resolve(name) caches the user information for a while",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores updates",
        "fullTitle": "PendingUpdatesMap #merge and #get stores updates",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "merges updates with preexisting updates via #merge",
        "fullTitle": "PendingUpdatesMap #merge and #get merges updates with preexisting updates via #merge",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns all updates that should be flushed",
        "fullTitle": "PendingUpdatesMap #elapsed returns all updates that should be flushed",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "uses #flushAt to determine deadlines",
        "fullTitle": "PendingUpdatesMap #elapsed uses #flushAt to determine deadlines",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "constructively merges two updates",
        "fullTitle": "PendingUpdate #merge constructively merges two updates",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails when key is not equal",
        "fullTitle": "PendingUpdate #merge fails when key is not equal",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns `cooldown` when deadline is far away",
        "fullTitle": "PendingUpdate #flushAt() returns `cooldown` when deadline is far away",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns `deadline` when deadline is < `cooldown`",
        "fullTitle": "PendingUpdate #flushAt() returns `deadline` when deadline is < `cooldown`",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns a settings object for the log subsystem",
        "fullTitle": "Settings #getLogSettingsObject returns a settings object for the log subsystem",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads settings from an extended JSON file",
        "fullTitle": "Settings #loadFromFile(json_file_path) loads settings from an extended JSON file",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads settings from an extended HJSON file",
        "fullTitle": "Settings #loadFromFile(json_file_path) loads settings from an extended HJSON file",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads settings from an extended YAML file",
        "fullTitle": "Settings #loadFromFile(json_file_path) loads settings from an extended YAML file",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "pops an item",
        "fullTitle": "Heap #pop pops an item",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns null if the heap is empty",
        "fullTitle": "Heap #pop returns null if the heap is empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [],
    "passes": [
      {
        "title": "allows scheduling an update",
        "fullTitle": "Metadata Updater allows scheduling an update",
        "duration": 45,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "starts a timer and runs #act every n ms",
        "fullTitle": "Metadata Updater/Controller #runEach(ms) starts a timer and runs #act every n ms",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "constructs an Flush operation for the update and returns it",
        "fullTitle": "Metadata Updater/Controller #flushOp(update) constructs an Flush operation for the update and returns it",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "pulls elapsed updates and flushes them to MongoDB",
        "fullTitle": "Metadata Updater/Controller #act pulls elapsed updates and flushes them to MongoDB",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "forwards calls",
        "fullTitle": "ErrorLogger forwards calls",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "catches and logs all exceptions, rethrowing afterwards",
        "fullTitle": "ErrorLogger catches and logs all exceptions, rethrowing afterwards",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "also works for async methods, waiting for the eventual result",
        "fullTitle": "ErrorLogger also works for async methods, waiting for the eventual result",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "writes event metadata to disk",
        "fullTitle": "Flush event with no existing metadata writes event metadata to disk",
        "duration": 23,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "doesn't destroy old earliest and latest",
        "fullTitle": "Flush event with existing metadata doesn't destroy old earliest and latest",
        "duration": 13,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "leaves base data intact",
        "fullTitle": "Flush event with existing metadata leaves base data intact",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns the user id",
        "fullTitle": "UserRepository #resolve(name) returns the user id",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "caches the user information for a while",
        "fullTitle": "UserRepository #resolve(name) caches the user information for a while",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "stores updates",
        "fullTitle": "PendingUpdatesMap #merge and #get stores updates",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "merges updates with preexisting updates via #merge",
        "fullTitle": "PendingUpdatesMap #merge and #get merges updates with preexisting updates via #merge",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns all updates that should be flushed",
        "fullTitle": "PendingUpdatesMap #elapsed returns all updates that should be flushed",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "uses #flushAt to determine deadlines",
        "fullTitle": "PendingUpdatesMap #elapsed uses #flushAt to determine deadlines",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "constructively merges two updates",
        "fullTitle": "PendingUpdate #merge constructively merges two updates",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "fails when key is not equal",
        "fullTitle": "PendingUpdate #merge fails when key is not equal",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns `cooldown` when deadline is far away",
        "fullTitle": "PendingUpdate #flushAt() returns `cooldown` when deadline is far away",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns `deadline` when deadline is < `cooldown`",
        "fullTitle": "PendingUpdate #flushAt() returns `deadline` when deadline is < `cooldown`",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns a settings object for the log subsystem",
        "fullTitle": "Settings #getLogSettingsObject returns a settings object for the log subsystem",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads settings from an extended JSON file",
        "fullTitle": "Settings #loadFromFile(json_file_path) loads settings from an extended JSON file",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads settings from an extended HJSON file",
        "fullTitle": "Settings #loadFromFile(json_file_path) loads settings from an extended HJSON file",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads settings from an extended YAML file",
        "fullTitle": "Settings #loadFromFile(json_file_path) loads settings from an extended YAML file",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "pops an item",
        "fullTitle": "Heap #pop pops an item",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns null if the heap is empty",
        "fullTitle": "Heap #pop returns null if the heap is empty",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "metadata"
  },
  {
    "stats": {
      "suites": 6,
      "tests": 7,
      "passes": 7,
      "pending": 0,
      "failures": 0,
      "start": "2019-05-06T11:53:33.264Z",
      "end": "2019-05-06T11:53:33.370Z",
      "duration": 106
    },
    "tests": [
      {
        "title": "returns a version-string",
        "fullTitle": "ProjectVersion#version when no \".api-version\" file is available returns a version-string",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns a git describe string",
        "fullTitle": "ProjectVersion#version when no \".api-version\" file is available returns a git describe string",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "reads .api-version and returns that constant",
        "fullTitle": "ProjectVersion#version when a \".api-version\" file exists in the project reads .api-version and returns that constant",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws an error",
        "fullTitle": "ProjectVersion#version when neither method works throws an error",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should not transform illegal usernames",
        "fullTitle": "subdomainToPath middleware using a minimal application should not transform illegal usernames",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should transform username into a path segment",
        "fullTitle": "subdomainToPath middleware using a minimal application should transform username into a path segment",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should accept dashes",
        "fullTitle": "subdomainToPath middleware using a minimal application should accept dashes",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [],
    "passes": [
      {
        "title": "returns a version-string",
        "fullTitle": "ProjectVersion#version when no \".api-version\" file is available returns a version-string",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "returns a git describe string",
        "fullTitle": "ProjectVersion#version when no \".api-version\" file is available returns a git describe string",
        "duration": 30,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "reads .api-version and returns that constant",
        "fullTitle": "ProjectVersion#version when a \".api-version\" file exists in the project reads .api-version and returns that constant",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "throws an error",
        "fullTitle": "ProjectVersion#version when neither method works throws an error",
        "duration": 4,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should not transform illegal usernames",
        "fullTitle": "subdomainToPath middleware using a minimal application should not transform illegal usernames",
        "duration": 25,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should transform username into a path segment",
        "fullTitle": "subdomainToPath middleware using a minimal application should transform username into a path segment",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should accept dashes",
        "fullTitle": "subdomainToPath middleware using a minimal application should accept dashes",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "middleware"
  },
  {
    "stats": {
      "suites": 3,
      "tests": 4,
      "passes": 4,
      "pending": 0,
      "failures": 0,
      "start": "2019-05-06T11:53:33.841Z",
      "end": "2019-05-06T11:53:33.865Z",
      "duration": 24
    },
    "tests": [
      {
        "title": "should parse token out",
        "fullTitle": "MethodContext #parseAuth should parse token out",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should also parse the callerId when available",
        "fullTitle": "MethodContext #parseAuth should also parse the callerId when available",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "checks expiry of the access",
        "fullTitle": "MethodContext #retrieveAccessFromId checks expiry of the access",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads the access",
        "fullTitle": "MethodContext #retrieveAccessFromId loads the access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [],
    "passes": [
      {
        "title": "should parse token out",
        "fullTitle": "MethodContext #parseAuth should parse token out",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should also parse the callerId when available",
        "fullTitle": "MethodContext #parseAuth should also parse the callerId when available",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "checks expiry of the access",
        "fullTitle": "MethodContext #retrieveAccessFromId checks expiry of the access",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "loads the access",
        "fullTitle": "MethodContext #retrieveAccessFromId loads the access",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "model"
  },
  {
    "stats": {
      "suites": 5,
      "tests": 16,
      "passes": 16,
      "pending": 0,
      "failures": 0,
      "start": "2019-05-06T11:53:34.688Z",
      "end": "2019-05-06T11:53:37.108Z",
      "duration": 2420
    },
    "tests": [
      {
        "title": "must return JPEG previews for \"picture/attached\" events and cache the result",
        "fullTitle": "event previews GET /<event id>/preview must return JPEG previews for \"picture/attached\" events and cache the result",
        "duration": 148,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept \".jpg\" extension in the path (backwards-compatibility)",
        "fullTitle": "event previews GET /<event id>/preview must accept \".jpg\" extension in the path (backwards-compatibility)",
        "duration": 48,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must adjust the desired size to the bigger standard size (if exists)",
        "fullTitle": "event previews GET /<event id>/preview must adjust the desired size to the bigger standard size (if exists)",
        "duration": 71,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must limit the desired size to the biggest standard size if too big",
        "fullTitle": "event previews GET /<event id>/preview must limit the desired size to the biggest standard size if too big",
        "duration": 123,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must serve the cached file if available",
        "fullTitle": "event previews GET /<event id>/preview must serve the cached file if available",
        "duration": 55,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must regenerate the cached file if obsolete",
        "fullTitle": "event previews GET /<event id>/preview must regenerate the cached file if obsolete",
        "duration": 114,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must respond with \"no content\" if the event type is not supported",
        "fullTitle": "event previews GET /<event id>/preview must respond with \"no content\" if the event type is not supported",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if the event does not exist",
        "fullTitle": "event previews GET /<event id>/preview must return a proper error if the event does not exist",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid requests missing an access token",
        "fullTitle": "event previews GET /<event id>/preview must forbid requests missing an access token",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid requests with unauthorized accesses",
        "fullTitle": "event previews GET /<event id>/preview must forbid requests with unauthorized accesses",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if event data is corrupted (no attachment object)",
        "fullTitle": "event previews GET /<event id>/preview must return a proper error if event data is corrupted (no attachment object)",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if event data is corrupted (no attached file)",
        "fullTitle": "event previews GET /<event id>/preview must return a proper error if event data is corrupted (no attached file)",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must work with animated GIFs too",
        "fullTitle": "event previews GET /<event id>/preview must work with animated GIFs too",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must clean up cached previews not accessed for one week by default",
        "fullTitle": "event previews POST /clean-up-cache must clean up cached previews not accessed for one week by default",
        "duration": 403,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must ignore files with no readable extended attribute",
        "fullTitle": "event previews POST /clean-up-cache must ignore files with no readable extended attribute",
        "duration": 352,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return OK",
        "fullTitle": "(index) OPTIONS / should return OK",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [],
    "passes": [
      {
        "title": "must return JPEG previews for \"picture/attached\" events and cache the result",
        "fullTitle": "event previews GET /<event id>/preview must return JPEG previews for \"picture/attached\" events and cache the result",
        "duration": 148,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must accept \".jpg\" extension in the path (backwards-compatibility)",
        "fullTitle": "event previews GET /<event id>/preview must accept \".jpg\" extension in the path (backwards-compatibility)",
        "duration": 48,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must adjust the desired size to the bigger standard size (if exists)",
        "fullTitle": "event previews GET /<event id>/preview must adjust the desired size to the bigger standard size (if exists)",
        "duration": 71,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must limit the desired size to the biggest standard size if too big",
        "fullTitle": "event previews GET /<event id>/preview must limit the desired size to the biggest standard size if too big",
        "duration": 123,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must serve the cached file if available",
        "fullTitle": "event previews GET /<event id>/preview must serve the cached file if available",
        "duration": 55,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must regenerate the cached file if obsolete",
        "fullTitle": "event previews GET /<event id>/preview must regenerate the cached file if obsolete",
        "duration": 114,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must respond with \"no content\" if the event type is not supported",
        "fullTitle": "event previews GET /<event id>/preview must respond with \"no content\" if the event type is not supported",
        "duration": 10,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if the event does not exist",
        "fullTitle": "event previews GET /<event id>/preview must return a proper error if the event does not exist",
        "duration": 8,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid requests missing an access token",
        "fullTitle": "event previews GET /<event id>/preview must forbid requests missing an access token",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must forbid requests with unauthorized accesses",
        "fullTitle": "event previews GET /<event id>/preview must forbid requests with unauthorized accesses",
        "duration": 14,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if event data is corrupted (no attachment object)",
        "fullTitle": "event previews GET /<event id>/preview must return a proper error if event data is corrupted (no attachment object)",
        "duration": 22,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return a proper error if event data is corrupted (no attached file)",
        "fullTitle": "event previews GET /<event id>/preview must return a proper error if event data is corrupted (no attached file)",
        "duration": 18,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must work with animated GIFs too",
        "fullTitle": "event previews GET /<event id>/preview must work with animated GIFs too",
        "duration": 49,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must clean up cached previews not accessed for one week by default",
        "fullTitle": "event previews POST /clean-up-cache must clean up cached previews not accessed for one week by default",
        "duration": 403,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must ignore files with no readable extended attribute",
        "fullTitle": "event previews POST /clean-up-cache must ignore files with no readable extended attribute",
        "duration": 352,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "should return OK",
        "fullTitle": "(index) OPTIONS / should return OK",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "previews-server"
  },
  {
    "stats": {
      "suites": 2,
      "tests": 3,
      "passes": 3,
      "pending": 0,
      "failures": 0,
      "start": "2019-05-06T11:53:37.624Z",
      "end": "2019-05-06T11:53:37.705Z",
      "duration": 81
    },
    "tests": [
      {
        "title": "making a call",
        "fullTitle": "Base API making a call",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "failing a call (server-side)",
        "fullTitle": "Base API failing a call (server-side)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "compiles a .proto 3 syntax file into a set of flow-type interfaces",
        "fullTitle": "Type Compilation compiles a .proto 3 syntax file into a set of flow-type interfaces",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [],
    "passes": [
      {
        "title": "making a call",
        "fullTitle": "Base API making a call",
        "duration": 29,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "failing a call (server-side)",
        "fullTitle": "Base API failing a call (server-side)",
        "duration": 2,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "compiles a .proto 3 syntax file into a set of flow-type interfaces",
        "fullTitle": "Type Compilation compiles a .proto 3 syntax file into a set of flow-type interfaces",
        "duration": 5,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "tprpc"
  },
  {
    "stats": {
      "suites": 7,
      "tests": 10,
      "passes": 10,
      "pending": 0,
      "failures": 0,
      "start": "2019-05-06T11:53:37.978Z",
      "end": "2019-05-06T11:53:37.989Z",
      "duration": 11
    },
    "tests": [
      {
        "title": "must build a correct tree for a given consistent array",
        "fullTitle": "tree utils buildTree() must build a correct tree for a given consistent array",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw an error if objects do not contain the necessary properties",
        "fullTitle": "tree utils buildTree() must throw an error if objects do not contain the necessary properties",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw an error if the object in argument is not an array",
        "fullTitle": "tree utils buildTree() must throw an error if the object in argument is not an array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must build a correct array for a given tree",
        "fullTitle": "tree utils flattenTree() must build a correct array for a given tree",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw an error if the object in argument is not an array",
        "fullTitle": "tree utils flattenTree() must throw an error if the object in argument is not an array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the first item matching the given iterator function",
        "fullTitle": "tree utils findInTree() must return the first item matching the given iterator function",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return null if no item matches the given iterator function",
        "fullTitle": "tree utils findInTree() must return null if no item matches the given iterator function",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return only items matching the given iterator function",
        "fullTitle": "tree utils filterTree() must return only items matching the given iterator function",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an array with values matching the iterator function for each item in the tree",
        "fullTitle": "tree utils collect() must return an array with values matching the iterator function for each item in the tree",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an array with the ids passed in argument plus those of all their descendants",
        "fullTitle": "tree utils expandIds() must return an array with the ids passed in argument plus those of all their descendants",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "pending": [],
    "failures": [],
    "passes": [
      {
        "title": "must build a correct tree for a given consistent array",
        "fullTitle": "tree utils buildTree() must build a correct tree for a given consistent array",
        "duration": 3,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw an error if objects do not contain the necessary properties",
        "fullTitle": "tree utils buildTree() must throw an error if objects do not contain the necessary properties",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw an error if the object in argument is not an array",
        "fullTitle": "tree utils buildTree() must throw an error if the object in argument is not an array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must build a correct array for a given tree",
        "fullTitle": "tree utils flattenTree() must build a correct array for a given tree",
        "duration": 1,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must throw an error if the object in argument is not an array",
        "fullTitle": "tree utils flattenTree() must throw an error if the object in argument is not an array",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return the first item matching the given iterator function",
        "fullTitle": "tree utils findInTree() must return the first item matching the given iterator function",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return null if no item matches the given iterator function",
        "fullTitle": "tree utils findInTree() must return null if no item matches the given iterator function",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return only items matching the given iterator function",
        "fullTitle": "tree utils filterTree() must return only items matching the given iterator function",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an array with values matching the iterator function for each item in the tree",
        "fullTitle": "tree utils collect() must return an array with values matching the iterator function for each item in the tree",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      },
      {
        "title": "must return an array with the ids passed in argument plus those of all their descendants",
        "fullTitle": "tree utils expandIds() must return an array with the ids passed in argument plus those of all their descendants",
        "duration": 0,
        "currentRetry": 0,
        "err": {}
      }
    ],
    "componentName": "utils"
  }
]